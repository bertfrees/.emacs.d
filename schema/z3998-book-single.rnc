default namespace = "http://www.daisy.org/ns/z3998/authoring/"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace d =
  "http://www.daisy.org/ns/z3998/authoring/features/description/"
namespace db = "http://docbook.org/ns/docbook"
namespace dcterms = "http://purl.org/dc/terms/"
namespace i = "http://www.daisy.org/ns/z3998/authoring/xforms/instance/"
namespace its = "http://www.w3.org/2005/11/its"
namespace m = "http://www.w3.org/1998/Math/MathML"
namespace rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
namespace rdfs = "http://www.w3.org/2000/01/rdf-schema#"
namespace rend =
  "http://www.daisy.org/ns/z3998/authoring/features/rend/"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace sel =
  "http://www.daisy.org/ns/z3998/authoring/features/select/"
namespace ssml = "http://www.w3.org/2001/10/synthesis"
namespace x = "http://www.w3.org/1999/xhtml"
namespace xforms = "http://www.w3.org/2002/xforms/"
namespace xlink = "http://www.w3.org/1999/xlink"
namespace xs = "http://www.w3.org/2001/XMLSchema"
namespace z = "http://www.daisy.org/ns/z3998/annotations/#"
namespace zrng = "http://www.daisy.org/ns/rng/annotations"

db:info [
  xml:lang = "en"
  "\x{a}" ~
  "        "
  db:title [ "The book schema " ]
  "\x{a}" ~
  "        "
  db:annotation [
    annotates = "/"
    "\x{a}" ~
    "         "
    db:para [
      "This driver file represents the RelaxNG implementation of the Z39.98-2012 Book Profile, and provides the schematic means of validating conformant documents. "
    ]
    "\x{a}" ~
    "         "
    db:para [
      "More information about this module is available at http://www.daisy.org/z3998/2012/auth/cm/#z3998.book.module"
    ]
    "\x{a}" ~
    "      "
  ]
  "\x{a}" ~
  "        "
  db:author [
    "\x{a}" ~
    "            "
    db:personname [ "Markus Gylling" ]
    "\x{a}" ~
    "            "
    db:email [ "mgylling@daisy.org" ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "        "
  db:legalnotice [
    "\x{a}" ~
    "            "
    db:para [
      "This module is licensed under a Creative Commons Attribution 3.0 license, a copy of which is available at \x{a}" ~
      "                "
      db:link [
        xlink:href = "http://creativecommons.org/licenses/by/3.0/"
        "http://creativecommons.org/licenses/by/3.0/"
      ]
      "\x{a}" ~
      "            "
    ]
    "\x{a}" ~
    "            "
    db:para [
      "For complete licensing information, please refer to the LICENSE file that came with this distribution, a copy of which is also available from the DAISY web site at \x{a}" ~
      "                "
      db:link [ xlink:href = "http://www.daisy.org" "www.daisy.org" ]
      "\x{a}" ~
      "            "
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "        "
  db:copyright [
    "\x{a}" ~
    "            "
    db:year [ "2009" ]
    "\x{a}" ~
    "            "
    db:year [ "2010" ]
    "\x{a}" ~
    "            "
    db:year [ "2011" ]
    "\x{a}" ~
    "            "
    db:year [ "2012" ]
    "\x{a}" ~
    "            "
    db:holder [ "DAISY Consortium" ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "        "
  db:revhistory [
    "\x{a}" ~
    "            "
    db:revision [
      "\x{a}" ~
      "                "
      db:date [ "2012-12-19" ]
      "\x{a}" ~
      "                "
      db:authorinitials [ "MGy" ]
      "\x{a}" ~
      "                "
      db:revdescription [
        "\x{a}" ~
        "                    "
        db:para [ " Initial version. " ]
        "\x{a}" ~
        "                    "
        db:para [
          " This revision history only reflects changes to the driver file, not to any of the modules included in it. "
        ]
        "\x{a}" ~
        "                "
      ]
      "\x{a}" ~
      "            "
    ]
    "\x{a}" ~
    "        "
  ]
  "\x{a}" ~
  "    "
]
start = z3998.document
z3998.document =
  
  ## The document element is the root element of all Z39.98-AI Profiles. The document element must include an xmlns attribute declaring the Z39.98-AI Core namespace and an 
  ##  xml.lang  attribute specifying the language of the document. 
  element document {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    rdfa.prefix.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.head,
    z3998.body
  }
z3998.head =
  
  ## The head element contains meta information about the complete or partial document contained in the enclosing 
  ##  document . The meta information in the head element is not document content in the context of Z39.98-AI documents, but may be used for display and other purposes when rendering documents into alternate formats. Refer to 
  ##  Document metadata  for the normative specification of required metadata in head. 
  element head {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.meta
     | z3998.description
     | z3998.expansion
     | z3998.definition
     | ssml.lexicon
     | xforms.model)+
  }
z3998.body =
  
  ## The body element contains the complete or partial content of the enclosing 
  ##  document . 
  element body {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    ssml.onlangfailure.attrib?,
    (empty | z3998.cover)?,
    z3998.frontmatter,
    z3998.bodymatter,
    z3998.backmatter?
  }
z3998.meta =
  
  ## The meta element expresses metadata information about the document, a document fragment or an external resource associated with the document. The meta element accepts attributes from the 
  ##  RDFa attributes collection  for capturing the metadata information. 
  element meta {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    ((rdfa.rel.attrib, rdfa.resource.attrib, z3998.meta*)
     | (rdfa.rev.attrib, rdfa.resource.attrib, z3998.meta*)
     | (rdfa.property.attrib, rdfa.content.attrib, z3998.meta*)
     | (rdfa.about.attrib,
        rdfa.property.attrib,
        rdfa.content.attrib,
        z3998.meta*)
     | (rdfa.about.attrib,
        rdfa.typeof.attrib,
        rdfa.content.attrib,
        z3998.meta*)
     | (rdfa.property.attrib,
        (text
         | z3998.object.text
         | z3998.sub
         | z3998.sup
         | z3998.char
         | z3998.span.text
         | z3998.emph.text
         | ssml.break
         | ssml.phoneme.text
         | ssml.prosody.text
         | ssml.say-as.text
         | ssml.sub.text
         | ssml.token.text
         | its-ruby
         | z3998.span
         | z3998.ref
         | z3998.code.phrase
         | z3998.object.phrase
         | z3998.address.phrase
         | z3998.noteref
         | z3998.note.phrase
         | z3998.annoref
         | z3998.ln
         | z3998.s
         | z3998.w
         | z3998.w
         | z3998.expansion
         | z3998.abbr
         | z3998.emph
         | z3998.time
         | z3998.name
         | z3998.definition
         | z3998.term
         | z3998.d
         | z3998.num
         | z3998.rend.linebreak
         | z3998.quote.phrase
         | z3998.citation
         | z3998.annotation.phrase
         | ssml.break
         | ssml.phoneme
         | ssml.prosody
         | ssml.say-as
         | ssml.sub
         | ssml.token
         | math
         | z3998.select.phrase
         | xforms.input
         | xforms.textarea
         | xforms.secret
         | xforms.select1
         | xforms.select
         | xforms.range
         | z3998.pagebreak)+)
     | (rdfa.about.attrib,
        rdfa.property.attrib,
        (text
         | z3998.object.text
         | z3998.sub
         | z3998.sup
         | z3998.char
         | z3998.span.text
         | z3998.emph.text
         | ssml.break
         | ssml.phoneme.text
         | ssml.prosody.text
         | ssml.say-as.text
         | ssml.sub.text
         | ssml.token.text
         | its-ruby
         | z3998.span
         | z3998.ref
         | z3998.code.phrase
         | z3998.object.phrase
         | z3998.address.phrase
         | z3998.noteref
         | z3998.note.phrase
         | z3998.annoref
         | z3998.ln
         | z3998.s
         | z3998.w
         | z3998.w
         | z3998.expansion
         | z3998.abbr
         | z3998.emph
         | z3998.time
         | z3998.name
         | z3998.definition
         | z3998.term
         | z3998.d
         | z3998.num
         | z3998.rend.linebreak
         | z3998.quote.phrase
         | z3998.citation
         | z3998.annotation.phrase
         | ssml.break
         | ssml.phoneme
         | ssml.prosody
         | ssml.say-as
         | ssml.sub
         | ssml.token
         | math
         | z3998.select.phrase
         | xforms.input
         | xforms.textarea
         | xforms.secret
         | xforms.select1
         | xforms.select
         | xforms.range
         | z3998.pagebreak)+)
     | (rdfa.about.attrib,
        rdfa.typeof.attrib,
        (text
         | z3998.object.text
         | z3998.sub
         | z3998.sup
         | z3998.char
         | z3998.span.text
         | z3998.emph.text
         | ssml.break
         | ssml.phoneme.text
         | ssml.prosody.text
         | ssml.say-as.text
         | ssml.sub.text
         | ssml.token.text
         | its-ruby
         | z3998.span
         | z3998.ref
         | z3998.code.phrase
         | z3998.object.phrase
         | z3998.address.phrase
         | z3998.noteref
         | z3998.note.phrase
         | z3998.annoref
         | z3998.ln
         | z3998.s
         | z3998.w
         | z3998.w
         | z3998.expansion
         | z3998.abbr
         | z3998.emph
         | z3998.time
         | z3998.name
         | z3998.definition
         | z3998.term
         | z3998.d
         | z3998.num
         | z3998.rend.linebreak
         | z3998.quote.phrase
         | z3998.citation
         | z3998.annotation.phrase
         | ssml.break
         | ssml.phoneme
         | ssml.prosody
         | ssml.say-as
         | ssml.sub
         | ssml.token
         | math
         | z3998.select.phrase
         | xforms.input
         | xforms.textarea
         | xforms.secret
         | xforms.select1
         | xforms.select
         | xforms.range
         | z3998.pagebreak)+)
     | (rdfa.typeof.attrib, z3998.meta*)
     | rdfa.typeof.attrib)
    >> sch:rule [
         context = "default:meta[@content]"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "string-length(normalize-space(@content)) > 0"
           "The meta content attribute must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.ref =
  
  ## The ref element represents a reference to an internal or external entity. The referenced entity is not required to be resolvable or includable in a processing or rendering context: the ref element may point to conceptual or physical items. The ref element may employ attributes from the 
  ##  xlink  attributes collection to specify the nature of the hyperlink, including or excluding expressions of link activation behavior. IDREF link relationships may also be established using the 
  ##  ref  attribute, but not in conjunction with the xlink attributes collection. 
  [
    sch:rule [
      context = "default:ref"
      "\x{a}" ~
      "                "
      sch:report [
        test = "descendant::default:ref"
        "The {ref} element must not contain descendant {ref} elements."
      ]
      "\x{a}" ~
      "                "
      sch:assert [
        test = "normalize-space(.) or *"
        "The ref element must neither be empty nor contain only whitespace. "
      ]
      "\x{a}" ~
      "            "
    ]
  ]
  element ref {
    ((xlink.href.attrib
      & xlink.type.attrib?
      & xlink.title.attrib?
      & xlink.show.attrib?
      & xlink.actuate.attrib?)?
     | z3998.ref.attrib?),
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    (z3998.span
     | text
     | z3998.object.text
     | z3998.sub
     | z3998.sup
     | z3998.char
     | z3998.span.text
     | z3998.emph.text
     | ssml.break
     | ssml.phoneme.text
     | ssml.prosody.text
     | ssml.say-as.text
     | ssml.sub.text
     | ssml.token.text
     | its-ruby
     | z3998.ref
     | z3998.code.phrase
     | z3998.object.phrase
     | z3998.address.phrase
     | z3998.noteref
     | z3998.note.phrase
     | z3998.annoref
     | z3998.ln
     | z3998.s
     | z3998.w
     | z3998.w
     | z3998.expansion
     | z3998.abbr
     | z3998.emph
     | z3998.time
     | z3998.name
     | z3998.definition
     | z3998.term
     | z3998.d
     | z3998.num
     | z3998.rend.linebreak
     | ssml.break
     | ssml.phoneme
     | ssml.prosody
     | ssml.say-as
     | ssml.sub
     | ssml.token
     | math
     | z3998.select.phrase
     | xforms.input
     | xforms.textarea
     | xforms.secret
     | xforms.select1
     | xforms.select
     | xforms.range
     | z3998.pagebreak)+
  }
z3998.ref.attrib =
  
  ## The ref attribute provides a generic mechanism to establish an association between the current element and one or more other elements in the document scope. The ref attribute must contain one or more space separated references to the 
  ##  IDs  of the associated elements. Elements adopting the ref attribute may express constraints on the nature of the referenced elements. 
  attribute ref {
    IDREFS.datatype
    >> sch:rule [
         context =
           "*[@ref][namespace-uri()='http://www.daisy.org/ns/z3998/authoring/']"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $id in tokenize(@ref, '\s+') satisfies count(index-of(tokenize(@ref, '\s+'), $id)) = 1"
           "The ref attribute must not reference the same ID multiple times. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $id in tokenize(@ref, '\s+') satisfies //*[@xml:id = $id]"
           "Each IDREF in the ref attribute must reference the ID of another element in the document. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $id in tokenize(@ref, '\s+') satisfies not(current() is //*[@xml:id eq $id])"
           "Elements carrying a ref attribute must not reference themselves. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.src.attrib =
  
  ## The src attribute contains a URI reference to an external resource to embed in the document, in place of the current element. Only references to resources that conform to one of the types in the 
  ##  srctype  attribute enumeration are allowed. 
  attribute src { URI.datatype }
z3998.srctype.attrib =
  
  ## The srctype attribute contains a 
  ##  MediaType  expression that identifies the type of resource referenced from the 
  ##  src  attribute. All Z39.98-AI profiles must allow the media types 
  ##  image/png , 
  ##  image/jpeg  and image/bmp. These three image types are jointly referred to as the "core image types". Z39.98-AI features may extend this enumeration to support additional media types. If the srctype attribute is not specified, processing agents must dereference the resource in the src attribute to identify its media type. 
  attribute srctype {
    
    ## The referenced resource is a 
    ##  PNG image . 
    "image/png"
    | 
      ## The referenced resource is a 
      ##  JPEG image . 
      "image/jpeg"
    | 
      ## The referenced resource is a BMP image. 
      "image/bmp"
    | "image/svg+xml"
  }
z3998.continuation.attrib =
  
  ## The continuation attribute provides a generic mechanism to establish a logical continuation of the current element cross one or more other elements in the document scope. The continuation attribute must contain one or more space separated references to the 
  ##  IDs  of the associated elements. Note that the element that carries the continuation attribute must not be referenced in this list. The order in which the references appear in the attribute value is not significant (i.e., the reference order need not match the document order of the referenced elements). Only elements with the same QName as the parent element of the attribute can be referenced (e.g., a paragraph cannot list a table as a continuation). Additionally, only elements following the current element in the document order may be referenced as continuations. Elements that are referenced as continuations must not have continuation attributes themselves. Logical connections allow for special formatting of elements when generating outputs (to establish the connection between emphasis that continues across multiple paragraphs for braille formatting, for example). When the continuation attribute has been attached to an element, all formatting instructions that apply to that element also apply to all the elements referenced in the attribute. Formatting instructions on the logical siblings, however, do not cascade. A processing agent that does not recognize logical connections must be able to process each individual element in the continuation without requiring special knowledge of the elements that came before (i.e., inheritance of formatting cannot be assumed). 
  [
    sch:rule [
      context = "*[@continuation]"
      "\x{a}" ~
      "                "
      sch:assert [
        test =
          "every $id in tokenize(@continuation, '\s+') satisfies count(index-of(tokenize(@continuation, '\s+'), $id)) = 1"
        "The continuation attribute must not reference the same ID multiple times. "
      ]
      "\x{a}" ~
      "                "
      sch:assert [
        test =
          "every $id in tokenize(@continuation, '\s+') satisfies current() << //*[@xml:id eq $id]"
        "Elements referenced by a continuation attribute must be located after the referencing element (i.e., in document order). "
      ]
      "\x{a}" ~
      "                "
      sch:assert [
        test =
          "every $id in tokenize(@continuation, '\s+') satisfies name(//*[@xml:id eq $id]) eq name(current())"
        "Elements referenced by a continuation attribute must have the same QName as the referencing element. "
      ]
      "\x{a}" ~
      "                "
      sch:assert [
        test =
          "every $id in tokenize(@continuation, '\s+') satisfies not(current() is //*[@xml:id eq $id])"
        "Elements carrying a continuation attribute must not reference themselves. "
      ]
      "\x{a}" ~
      "            "
    ]
  ]
  attribute continuation { IDREFS.datatype }
z3998.section =
  
  ## The section element represents a structural division of a document. A structural division is defined as any grouping of content that has significance to the hierarchy of the document, which can include major divisions like parts, sections, chapters, etc. or minor divisions like author biographies. 
  element section {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.depth.attrib?,
    ((z3998.h & z3998.pagebreak*)
     | ((z3998.h?
         & (z3998.hd
            | z3998.block
            | z3998.p
            | z3998.transition
            | z3998.list
            | z3998.table
            | z3998.code.block
            | z3998.quote.block
            | z3998.citation.block
            | z3998.object.block
            | z3998.address
            | z3998.note
            | z3998.annotation
            | z3998.aside
            | z3998.caption
            | z3998.verse
            | z3998.description
            | ssml.break
            | math
            | z3998.select.block
            | xforms.group
            | xforms.repeat
            | z3998.feature.description
            | z3998.toc.block
            | z3998.glossary.block)+
         & z3998.pagebreak*),
        ((z3998.section
          | z3998.aside.section
          | z3998.bibliography
          | z3998.glossary)*
         & z3998.pagebreak*))
     | ((z3998.h? & z3998.pagebreak*),
        ((z3998.section
          | z3998.aside.section
          | z3998.bibliography
          | z3998.glossary)+
         & z3998.pagebreak*)))
  }
z3998.h =
  
  ## The h element represents a structural heading. The h element is strongly associated with the 
  ##  section  element and its specializations. Each section typically allows zero or one h element child. 
  element h {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (((z3998.span
       | text
       | z3998.object.text
       | z3998.sub
       | z3998.sup
       | z3998.char
       | z3998.span.text
       | z3998.emph.text
       | ssml.break
       | ssml.phoneme.text
       | ssml.prosody.text
       | ssml.say-as.text
       | ssml.sub.text
       | ssml.token.text
       | its-ruby
       | z3998.ref
       | z3998.code.phrase
       | z3998.object.phrase
       | z3998.address.phrase
       | z3998.noteref
       | z3998.note.phrase
       | z3998.annoref
       | z3998.ln
       | z3998.s
       | z3998.w
       | z3998.w
       | z3998.expansion
       | z3998.abbr
       | z3998.emph
       | z3998.time
       | z3998.name
       | z3998.definition
       | z3998.term
       | z3998.d
       | z3998.num
       | z3998.rend.linebreak
       | ssml.break
       | ssml.phoneme
       | ssml.prosody
       | ssml.say-as
       | ssml.sub
       | ssml.token
       | math
       | z3998.select.phrase
       | xforms.input
       | xforms.textarea
       | xforms.secret
       | xforms.select1
       | xforms.select
       | xforms.range
       | z3998.pagebreak)+
      | z3998.hpart)+)
    >> sch:rule [
         context = "default:h"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The h element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.hpart =
  
  ## The hpart element represents a segment of a structural heading. The hpart element is typically used to separate numeric identifiers from headings or to separate segments of headings broken onto separate lines. 
  element hpart {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((z3998.span
      | text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:hpart"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The hpart element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.hd =
  
  ## The hd element represents a free-floating heading that is not associated with the hierarchical structure of the document. The 
  ##  ref  attribute may be used to associate an hd element with a construct that it acts as a heading for. 
  element hd {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.ref.attrib?,
    ((z3998.span
      | text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:hd"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The hd element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.block =
  
  ## The block element establishes an association between a group of elements. The block element differs and is subordinate to the 
  ##  section  element in that it is not used to represent the structural outline of a document. A block only establishes a general association, and is a semantically neutral element by default. Attributes attached to the block reflect a general commonality amongst the children: a 
  ##  role  attribute can be attached to express the semantic nature of the grouping; a 
  ##  class  attribute to establish common formatting; an 
  ##  xml.lang  attribute to indicate the language of the elements; and so forth. If the children of the block have a strong association to a single element, the 
  ##  block.associate  attribute can be used to make this relationship explicit (e.g., in a figure, that all children are connected to the image). 
  element block {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.block.associate.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:block"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The block element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.block.associate.attrib =
  
  ## The associate attribute identifies the child element of a 
  ##  block  to which all other children are bound. The associate attribute takes a single IDREF that must point to one of its children as a value. All the other children assume an implict reference to the element through this value, allowing the 
  ##  ref  attribute to be omitted from them. 
  attribute associate {
    IDREF.datatype
    >> sch:rule [
         context = "*[@associate]"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "child::*[@xml:id = current()/@associate]"
           "The IDREF in the associate attribute must reference the ID of a child element. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.p =
  
  ## The p element represents a paragraph of text consisting of one or several sentences. The 
  ##  class  attribute together with a CSS stylesheet should be used to retain any formatting information specific to a paragraph, such as first line indenting. When print layout has to be strictly followed in converting a document to electronic format, paragraphs may be split by other elements such as full page images. Refer to the 
  ##  continuation  attribute for more information on how to indicate that two p elements actually constitute a single whole. 
  element p {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:p"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The p element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.transition =
  
  ## The transition element represents context changes and other shifts in the narrative flow or content of a document. The shift represented by a transition does not infer structural meaning on the elements that precede or follow it (see the 
  ##  section  element). A typical example of a transition in print documents is a spaced gap between paragraphs, which may include centered asterisks or other glyphs (often referred to as a space break). The Content Rendition feature's 
  ##  symbol  attribute can be used to represent a character marker associated with the transition, and the 
  ##  src  attribute can be used to reference an image. If both attributes are omitted, the transition is treated as a whitespace gap. 
  element transition {
    xml.id.attrib?
    & xml.space.attrib?
    & xml.base.attrib?
    & z3998.class.attrib?
    & xml.lang.attrib?
    & its.dir.attrib?
    & its.translate.attrib?
    & rdfa.about.attrib?
    & rdfa.content.attrib?
    & rdfa.datatype.attrib?
    & rdfa.typeof.attrib?
    & rdfa.property.attrib?
    & rdfa.rel.attrib?
    & rdfa.resource.attrib?
    & rdfa.rev.attrib?
    & z3998.desc.attrib?
    & z3998.by.attrib?
    & z3998.select.selid.attrib?
    & z3998.role.attrib?
    & z3998.continuation.attrib?
    & ssml.onlangfailure.attrib?
    & (z3998.rend.symbol.attrib
       | (z3998.src.attrib, z3998.srctype.attrib?))?
  }
z3998.list =
  
  ## The list element represents a simple list of items, either ordered or unordered. The optional type attribute specifies the HTML-style ordered and unordered nature of the list. By default, an unordered list is prefixed by bullets and an ordered list by numeric values. To change this behavior, refer to the Content Rendition feature's 
  ##  prefix  attributes. If the type attribute is omitted, then there is no default formatting. The list element is not intended to structure semantically meaningful sets of entries as found in indexes, bibliographies and glossaries. 
  element list {
    (xml.id.attrib?
     & xml.space.attrib?
     & xml.base.attrib?
     & z3998.class.attrib?
     & xml.lang.attrib?
     & its.dir.attrib?
     & its.translate.attrib?
     & rdfa.about.attrib?
     & rdfa.content.attrib?
     & rdfa.datatype.attrib?
     & rdfa.typeof.attrib?
     & rdfa.property.attrib?
     & rdfa.rel.attrib?
     & rdfa.resource.attrib?
     & rdfa.rev.attrib?
     & z3998.desc.attrib?
     & z3998.by.attrib?
     & z3998.select.selid.attrib?
     & z3998.role.attrib?
     & z3998.continuation.attrib?
     & ssml.onlangfailure.attrib?
     & ((z3998.list.type.ordered.attrib
         & z3998.list.start.attrib?
         & z3998.rend.list.ordered.prefix.attrib?)
        | (z3998.list.type.unordered.attrib
           & z3998.rend.list.unordered.prefix.attrib?)
        | empty)
     & z3998.depth.attrib?),
    (z3998.list.item.block+ & z3998.pagebreak*)
  }
z3998.list.type.unordered.attrib &=
  
  ## Specifies whether the items in the list are ordered or unordered. 
  attribute type {
    
    ## The order of the items in this list is insignificant. 
    "unordered"
  }
z3998.list.type.ordered.attrib &=
  
  ## Specifies whether the items in the list are ordered or unordered. 
  attribute type {
    
    ## The order of the items in this list is significant. 
    "ordered"
  }
z3998.list.start.attrib =
  
  ## The start attribute specifies the ordinal value for the first list item's prefix. If omitted, the implicit value 1 is assumed. This attribute is only valid when used with ordered lists (as defined by the presence and value of the type attribute). 
  attribute start { Integer.datatype }
z3998.list.item.block =
  
  ## The item element represents a single item in a list. The number or glyph that appears before the item is typically controlled by the attributes specified on the parent 
  ##  list  element together with the number of preceding items. The Content Rendition feature's 
  ##  prefix  attribute allows this default behaviour to be overridden for individual items, however. 
  element item {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.rend.list.item.prefix.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:item"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The item element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.table =
  
  ## The table element represents a single instance of tabular data arranged in rows and columns. A table may consist of one or more tr elements or may be divided into 
  ##  table.thead , 
  ##  table.tbody  and 
  ##  table.tfoot  divisions. A table may contain one or more 
  ##  table.colgroup  elements, for expressing common column formatting and properties. 
  element table {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.table.colgroup*,
    ((z3998.table.thead?, z3998.table.tbody+, z3998.table.tfoot?)
     | (z3998.table.tr.tr & z3998.pagebreak*)+)
  }
z3998.table.colgroup =
  
  ## The colgroup element allows a set of properties to be defined for the cells in one or more table columns. The colgroup can define a common set of properties for one or more columns using the 
  ##  table.span  attribute, in which case it must be an empty element. To specify different properties for different columns, the colgroup must contain one or more 
  ##  table.col  elements with the properties for those columns. A colgroup must not contain both a span attribute and child col elements. 
  element colgroup {
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    (z3998.table.span.attrib | z3998.table.col+)
  }
z3998.table.span.attrib =
  
  ## The span attribute specifies the number of columns the properties defined in a 
  ##  table.colgroup  or 
  ##  table.col  apply to. If a colgroup element contains child col elements, the span is determined automatically from the number of child col elements and any respective span values they define. If omitted, the implicit value 1 is assumed. 
  attribute span { PositiveInteger.datatype }
z3998.table.col =
  
  ## The col element allows a set of properties to be defined for the cells in one or more table columns. The optional 
  ##  table.span  attribute indicates the number of adjoining columns to which the properties apply. 
  element col {
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    z3998.table.span.attrib?
  }
z3998.table.thead =
  
  ## The thead element represents the collection of 
  ##  table  header rows. 
  element thead {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.table.tr.tr & z3998.pagebreak*)+
  }
z3998.table.tfoot =
  
  ## The tfoot element represents the collection of 
  ##  table  footer rows. Note that contrary to the 
  ##  XHTML Modularization 1.1 tables module tfoot element , this element is placed following the tbody element. 
  element tfoot {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.table.tr.tr & z3998.pagebreak*)+
  }
z3998.table.tbody =
  
  ## The tbody element represents a collection of 
  ##  table  body rows. Multiple tbody elements are allowed to enable representation of sections of rows. 
  element tbody {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.table.tr.tr & z3998.pagebreak*)+
  }
z3998.table.th =
  
  ## The th element represents a single table cell containing header information. The optional 
  ##  table.scope  attribute can be used to express the column(s) or row(s) to which the header applies. 
  element th {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.table.colspan.attrib?,
    z3998.table.rowspan.attrib?,
    z3998.table.headers.attrib?,
    z3998.table.scope.attrib?,
    z3998.table.th.abbr.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
  }
z3998.table.th.abbr.attrib =
  
  ## The abbr attribute specifies an abbreviated header value. 
  attribute abbr { text }
z3998.table.td =
  
  ## The td element represents a single table cell. The optional 
  ##  table.colspan  and 
  ##  table.rowspan  attributes can be used to specify that a column extends across or down more than one cell, respectively. The optional 
  ##  table.scope  attribute can be used to express that the current cell represents a header for columns(s) or row(s) defined by the attribute's value. 
  element td {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.table.colspan.attrib?,
    z3998.table.rowspan.attrib?,
    z3998.table.headers.attrib?,
    z3998.table.scope.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak
      | z3998.ln)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
  }
z3998.table.colspan.attrib =
  
  ## The colspan attribute specifies the number of columns spanned by the current cell. The implicit value of this attribute is 1. The value 0 indicates that the cell spans all columns from the current column to the last column of the 
  ##  table.colgroup  in which the cell is defined. 
  attribute colspan { NonNegativeInteger.datatype }
z3998.table.rowspan.attrib =
  
  ## The rowspan attribute specifies the number of rows spanned by the current cell. The implicit value of this attribute is 1. The value 0 indicates that the cell spans all rows from the current row to the last row of the current table section (rowgroup) in which the cell is defined (where the 
  ##  table.thead , 
  ##  table.tbody , and 
  ##  table.tfoot  elements are considered rowgroups). 
  attribute rowspan { NonNegativeInteger.datatype }
z3998.table.scope.attrib =
  
  ## The scope attribute specifies the set of data cells for which the current header cell provides header information. This attribute may be used in place of the 
  ##  table.headers  attribute, especially for simple tables. 
  attribute scope {
    
    ## The current cell provides header information for the rest of the row that contains it. 
    "row"
    | 
      ## The current cell provides header information for the rest of the column that contains it. 
      "col"
    | 
      ## The header cell provides header information for the rest of the row group that contains it. 
      "rowgroup"
    | 
      ## The header cell provides header information for the rest of the column group that contains it. 
      "colgroup"
  }
z3998.table.headers.attrib =
  
  ## The headers attribute specifies the list of header cells that provide header information for the current data cell. This attribute requires a space separated list of valid 
  ##  ID  references that resolves to 
  ##  th  elements. 
  attribute headers {
    IDREFS.datatype
    >> sch:rule [
         context = "default:*[@headers]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $idref in tokenize(current()/@headers,'\s+') satisfies ancestor::default:table[not(descendant::default:table)]//default:th[@xml:id=$idref]"
           "The headers attribute must resolve to a th in the current table. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.code.block =
  
  ## The code element is intended for general instances of code as found in works of fiction and similar non-technical documents, which includes computer programming code, commands and command input/output as well as representations of numeric and text coding systems, such as Morse code. For computer programming books, manuals and specifications, specializing the code element or using a computer markup feature is recommended. 
  element code {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((z3998.code.lngroup | z3998.code.ln | z3998.pagebreak)+
     | (z3998.block
        | z3998.hd
        | z3998.p
        | z3998.transition
        | z3998.object.block
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:code"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The code element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.code.lngroup =
  
  ## The lngroup element for code represents a grouping of ln code elements. Lines of code may be grouped to show a section of a coded message, a computer program, methods within a program, to separate programs from sample input/output, etc. 
  element lngroup {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.code.ln+ & z3998.pagebreak*)
  }
z3998.code.ln =
  
  ## The ln element for the code element represents a single line of code. The 
  ##  lnum  element can be added at the start of the ln for code examples that include line numbers. 
  element ln {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    (z3998.lnum?
     & (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:ln"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::default:ln)"
           "The ln element must not contain descendant ln elements. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ln element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.code.phrase =
  
  ## The code element is intended for general instances of code as found in works of fiction and similar non-technical documents, which includes computer programming code, commands and command input/output as well as representations of numeric and text coding systems, such as Morse code. For computer programming books, manuals and specifications, specializing the code element or using a computer markup feature is recommended. 
  element code {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:code"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The code element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.quote.block =
  
  ## The quote element represents a quotation from a real or fictitious source. When citing the source of a quotation, the 
  ##  citation  must be explicitly linked to the quote by means of the 
  ##  ref  attribute. If a quote element contains only a single child citation element, and the citation does not contain a ref attribute or child 
  ##  ref  element, the association between the two elements is implied. If a quote does not contain a citation, it can still be linked to the work it is cited from by attaching a 
  ##  ref  attribute referencing an entry in a 
  ##  bibliography , for example. To reference other resources, including resources external to the current document, the 
  ##  xlink.href  attribute must be used. The 
  ##  role  attribute optionally expresses the semantic nature of the quote. The role value epigraph, for example, indicates the quoted passage or verse represents an epigraph for the document or section. 
  element quote {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.ref.attrib
     | (xlink.href.attrib
        & xlink.type.attrib?
        & xlink.title.attrib?
        & xlink.show.attrib?
        & xlink.actuate.attrib?))?,
    (
     ## specialize the block model to allow linegroups and lines 
     (z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak
      | z3998.lngroup
      | z3998.ln)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:quote"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The quote element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.quote.phrase =
  
  ## The quote element represents a quotation from a real or fictitious source. When citing the source of a quotation, the 
  ##  citation  must be explicitly linked to the quote by means of the 
  ##  ref  attribute. If a quote element contains only a single child citation element, and the citation does not contain a ref attribute or child 
  ##  ref  element, the association between the two elements is implied. If a quote does not contain a citation, it can still be linked to the work it is cited from by attaching a 
  ##  ref  attribute referencing an entry in a 
  ##  bibliography , for example. To reference other resources, including resources external to the current document, the 
  ##  xlink.href  attribute must be used. The 
  ##  role  attribute optionally expresses the semantic nature of the quote. The role value epigraph, for example, indicates the quoted passage or verse represents an epigraph for the document or section. Quotation marks should be included within the element if they must be retained in the file. The use of CSS for appending these characters is recommended, however, for the flexibility it allows to change the characters depending on the desired output. 
  element quote {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    (z3998.ref.attrib
     | (xlink.href.attrib
        & xlink.type.attrib?
        & xlink.title.attrib?
        & xlink.show.attrib?
        & xlink.actuate.attrib?))?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:quote"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The quote element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.citation.block =
  
  ## The citation element represents an author's acknowledgment of the original author and/or work of a directly or indirectly borrowed idea, quote or other resource. Citations typically occur in conjunction with epigraphs, quotes, illustrations, charts and diagrams. The Block variant is an adaptation for use where the citation is offset from the quoted material. The optional 
  ##  ref  attribute on the citation element is used to establish an explicit association between the citation and the passage or resource it references; the placement of the citation does not, by default, imply an association with any element in the document. Some elements do provide a mechanism for implied relationships, however (see the 
  ##  quote  element, for example). When adding citations, refer to the documentation for the element the citation is being attached to for more information. A citation can also be linked to the work it cites by including a child 
  ##  ref  element. A 
  ##  ref  attribute can be attached to the nested ref element to reference a work in the current document's 
  ##  bibliography , for example. To reference other resources, including resources external to the current document, the 
  ##  xlink.href  attribute must be used instead. 
  element citation {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.ref.attrib
     | (xlink.href.attrib
        & xlink.type.attrib?
        & xlink.title.attrib?
        & xlink.show.attrib?
        & xlink.actuate.attrib?))?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:citation"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The citation element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:citation//default:ref[@ref]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "some $entry in //default:bibliography/default:entry satisfies current()/@ref eq $entry/@xml:id "
           "The ref attribute on the ref element must refer to an entry in a bibliography when nested inside a citation element. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.citation =
  
  ## The citation element represents an author's acknowledgment of the original author and/or work of a directly or indirectly borrowed idea, quote or other resource. Citations typically occur in conjunction with epigraphs, quotes, illustrations, charts and diagrams. The Phrase variant is an adaptation for use where citations are included inline with the quoted material. The optional 
  ##  ref  attribute on the citation element is used to establish an explicit association between the citation and the passage or resource it references; the placement of the citation does not, by default, imply an association with any element in the document. Some elements do provide a mechanism for implied relationships, however (see the 
  ##  quote  element, for example). When adding citations, refer to the documentation for the element the citation is being attached to for more information. A citation can also be linked to the work it cites by including a child 
  ##  ref  element. A 
  ##  ref  attribute can be attached to the nested ref element to reference a work in the current document's 
  ##  bibliography , for example. To reference other resources, including resources external to the current document, the 
  ##  xlink.href  attribute must be used instead. Parentheses, brackets and other enclosing characters should be included within the citation element if they must be retained in the file. The use of CSS for appending these characters is recommended, however, for the flexibility it allows to change the characters depending on the desired output. 
  element citation {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    (z3998.ref.attrib
     | (xlink.href.attrib
        & xlink.type.attrib?
        & xlink.title.attrib?
        & xlink.show.attrib?
        & xlink.actuate.attrib?))?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:citation"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The citation element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:citation//default:ref[@ref]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "some $entry in //default:bibliography/default:entry satisfies current()/@ref eq $entry/@xml:id "
           "The ref attribute on the ref element must refer to an entry in a bibliography when nested inside a citation element. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.object.block =
  
  ## The object element contains a reference to an external resource, such as a graphic or video. The Block variant is an adaptation for use embedding objects that are intended to be offset from any surrounding block elements. The referenced resource may be an image, video, XML text, or other content, but its media type must be supported by the current profile and features in use. The optional srctype attribute carries an enumeration of the allowed media types. The formal behavior of the object element is defined by 
  ##  XHTML 1.1 . 
  element object {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    (z3998.src.attrib, z3998.srctype.attrib?),
    (empty
     | z3998.description
     | (z3998.hd
        | z3998.block
        | z3998.p
        | z3998.transition
        | z3998.list
        | z3998.table
        | z3998.code.block
        | z3998.quote.block
        | z3998.citation.block
        | z3998.object.block
        | z3998.address
        | z3998.note
        | z3998.annotation
        | z3998.aside
        | z3998.caption
        | z3998.verse
        | z3998.description)+
     | (z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | text)+)
    >> sch:rule [
         context = "default:object"
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "descendant::*[namespace-uri(.) = 'http://www.w3.org/1998/Math/MathML']"
           "The {object} element must not contain descendant elements from the MathML feature grammar."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.object.phrase =
  
  ## The object element contains a reference to an external resource, such as a graphic or video. The Phrase variant is an adaption for use embedding objects in phrasal constructs. The referenced resource may be an image, video, XML text, or other content, but its media type must be supported by the current profile and features in use. The optional srctype attribute carries an enumeration of the allowed media types. The formal behavior of the object element is defined by 
  ##  XHTML 1.1 . 
  element object {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    (z3998.src.attrib, z3998.srctype.attrib?),
    (empty
     | z3998.description.phrase
     | (z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | text)+)
    >> sch:rule [
         context = "default:object"
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "descendant::*[namespace-uri(.) = 'http://www.w3.org/1998/Math/MathML']"
           "The {object} element must not contain descendant elements from the MathML feature grammar."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.object.text =
  
  ## The object element contains a reference to an external resource, such as a graphic or video. The Text variant is an adaption for use representing objects at the character level. The referenced resource may be an image, video, XML text, or other content, but its media type must be supported by the current profile and features in use. The optional srctype attribute carries an enumeration of the allowed media types. The formal behavior of the object element is defined by 
  ##  XHTML 1.1 . 
  element object {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.src.attrib, z3998.srctype.attrib?),
    (empty
     | z3998.description.text
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:object"
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "descendant::*[namespace-uri(.) = 'http://www.w3.org/1998/Math/MathML']"
           "The {object} element must not contain descendant elements from the MathML feature grammar."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.address =
  
  ## The address element represents both physical locations (postal, geographic, etc.) and virtual locations (http, email, ftp, etc.). The Block variant is an adaptation for use marking multi-line addresses (e.g., postal addresses). The 
  ##  role  attribute optionally expresses the type of address. If omitted, the implicit value postal is assumed. 
  element address {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.address.role.attrib?,
    z3998.ref.attrib?,
    (xlink.href.attrib
     & xlink.type.attrib?
     & xlink.title.attrib?
     & xlink.show.attrib?
     & xlink.actuate.attrib?)?,
    ((z3998.lngroup | z3998.ln | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:address"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The address element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.address.role.attrib =
  attribute role {
    list {
      (CURIE.datatype
       | 
         ## An internet protocol address. 
         "ip"
       | 
         ## An email address. 
         "email"
       | 
         ## A file transfer protocol address. 
         "ftp"
       | 
         ## A postal or mailing address. 
         "postal"
       | 
         ## A hypertext transfer protocol address. 
         "http"
       | 
         ## A positional location, typically expressed by coordinates. 
         "geographic")+
    }
  }
z3998.address.phrase =
  
  ## The address element represents both physical locations (postal, geographic, etc.) and virtual locations (http, email, ftp, etc.). The Phrase variant is an adaptation for use for addresses that are embedded within the text flow (typically web and email addresses). The 
  ##  role  attribute optionally expresses the type of address. If omitted, the implicit value postal is assumed. 
  element address {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.address.role.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    (xlink.href.attrib
     & xlink.type.attrib?
     & xlink.title.attrib?
     & xlink.show.attrib?
     & xlink.actuate.attrib?)?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:address"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The address element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.note =
  
  ## The note element represents a single footnote or endnote. The Block variant is an adaptation for use including notes between block elements. Notes provide or reference sources of additional information, or acknowledge the source of a quotation or idea. In printed matter, they are usually distinguishable from annotations by their location either at the bottom of print pages, at the end of sections or in the back matter of a document. Each note is typically referenced by a 
  ##  noteref  or prefixed by a page location (when explicit references have been omitted from the text). If the note does not have a referent in a Z39.98-AI document, it must include a 
  ##  ref  attribute that references back to the nearest element in the document to the content to which it applies. The 
  ##  role  attribute optionally expresses the semantic nature of the note. The value can be either footnote or endnote. If omitted, the implicit value footnote is assumed. When a note is prefixed by a number or symbol, that identifier should be included using the Content Rendition feature's 
  ##  prefix  attribute. 
  element note {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.ref.attrib?,
    z3998.rend.prefix.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:note"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "key('noterefs', @xml:id) or id(current()/@ref)"
           "The note element must either be referenced by a noteref or reference another element in the document. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The note element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.note.phrase =
  
  ## The note element represents a single footnote or endnote. The Phrase variant is an adaptation for use including notes inline in phrase contexts. Notes provide or reference sources of additional information, or acknowledge the source of a quotation or idea. In printed matter, they are usually distinguishable from annotations by their location either at the bottom of print pages, at the end of sections or in the back matter of a document. Each note is typically referenced by a 
  ##  noteref  or prefixed by a page location (when explicit references have been omitted from the text). If the note does not have a referent in a Z39.98-AI document, it must include a 
  ##  ref  attribute that references back to the nearest element in the document to the content to which it applies. The 
  ##  role  attribute optionally expresses the semantic nature of the note. The value can be either footnote or endnote. If omitted, the implicit value footnote is assumed. When a note is prefixed by a number or symbol, that identifier should be included using the Content Rendition feature's 
  ##  prefix  attribute. 
  element note {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    z3998.ref.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:note"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "key('noterefs', @xml:id) or id(current()/@ref)"
           "The note element must either be referenced by a noteref or reference another element in the document. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The note element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.noteref =
  
  ## The noteref element represents a textual reference to a 
  ##  note . Note references typically appear as superscripted numbers or symbols within the narrative flow but may also appear as linked words, especially in electronic formats. The 
  ##  ref  attribute is used to establish the link between the note reference and its associated note. By default, the text content of the noteref represents the link reference and is treated as document content. When superscripted numbers or symbols are used to identify the corresponding note, the 
  ##  noteref.value  attribute should be used. The noteref must be an empty element when attaching a value attribute; it it not permitted to include text content and a value attribute. 
  element noteref {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    z3998.ref.attrib,
    z3998.noteref.value.attrib?,
    (empty
     | (z3998.span
        | text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:noteref"
         "\x{a}" ~
         "                "
         sch:report [
           test = "@value and (count(*|text()[normalize-space()]) > 0)"
           "The {value} attribute can only be used on empty {noteref} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "not(@value) and (count(*|text()[normalize-space()]) = 0)"
           "A {noteref} element cannot be empty and not include a {value} attribute."
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $ref in tokenize(current()/@ref, ' +') satisfies key('notes', $ref)"
           "The IDREF(s) in the ref attribute must resolve to note elements. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:noteref"
         role = "warning"
         "\x{a}" ~
         "                "
         sch:report [
           role = "warning"
           test =
             "(count(node()[normalize-space()]) = 1) and child::default:sup"
           "Superscripted referents should be included in a {value} attribute, not as text content."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.noteref.value.attrib =
  
  ## The noteref value attribute provides the number or symbol that represents the current note reference. The value attribute allows any text string as an identifier. 
  attribute value { NonEmptyString.datatype }
z3998.annotation =
  
  ## The annotation element represents an annotation that an author, editor, publisher, or other individual or agency has added to a document. Unless an annotation element has a 
  ##  role  value of temporary, it must reference at least one element in the document using the 
  ##  ref  attribute or be referenced by at least one 
  ##  annoref . For annotations that apply to more than one element, use a space-separated list of xml:id values in the ref attribute. The 
  ##  ref  attribute identifies the specific element(s) being annotated by referencing their xml:id values. The annotation element should not be used to add descriptions, footnotes or endnotes. Refer to the 
  ##  description  and 
  ##  note  elements for more information. 
  element annotation {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.annotation.role.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.ref.attrib?,
    z3998.rend.prefix.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:annotation[not(@role='temporary')]"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "key('annorefs', @xml:id) or id(current()/@ref)"
           "The annotation element must be referenced by an annoref or reference another element in the document unless it has the role value temporary. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The annotation element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:annotation[@role='temporary']"
         role = "warning"
         "\x{a}" ~
         "                "
         sch:report [
           test = "."
           "Annotations with a {role} value of {temporary} must be removed prior to document finalization."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.annotation.phrase =
  
  ## The annotation element represents an annotation that an author, editor, publisher, or other individual or agency has added to a document. The inline inclusion of annotation elements does not influence the rendering of the annotations or reflect their appearance in a print medium; inlining allows annotations to be included as close to their referenced element as is desired. It is equally valid for Block-layer annotations to reference inline elements. Unless an annotation element has a 
  ##  role  value of temporary, it must reference at least one element in the document using the 
  ##  ref  attribute or be referenced by at least one 
  ##  annoref . For annotations that apply to more than one element, use a space-separated list of xml:id values in the ref attribute. The 
  ##  ref  attribute identifies the specific element(s) being annotated by referencing their xml:id values. The annotation element should not be used to add descriptions, footnotes or endnotes. Refer to the 
  ##  description  and 
  ##  note  elements for more information. 
  element annotation {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.annotation.role.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    z3998.ref.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:annotation[not(@role='temporary')]"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "key('annorefs', @xml:id) or id(current()/@ref)"
           "The annotation element must be referenced by an annoref or reference another element in the document unless it has the role value temporary. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The annotation element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:annotation[@role='temporary']"
         role = "warning"
         "\x{a}" ~
         "                "
         sch:report [
           test = "."
           "Annotations with a {role} value of {temporary} must be removed prior to document finalization."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.annotation.role.attrib =
  attribute role {
    list {
      (CURIE.datatype
       | 
         ## An annotation whose purpose is to provide a clarification. 
         "clarification"
       | 
         ## An annotation whose purpose is to provide a correction. 
         "correction"
       | 
         ## An annotation whose purpose is to indicate an alteration made to the source document, such as the re-arrangement or removal of content. 
         "alteration"
       | 
         ## A temporary annotation not intended as part of the finished document, such as a production note 
         "production"
       | 
         ## An annotation whose purpose is to describe some aspect of the document layout, such as the formatting of a page or conventions used in rendering the content. 
         "presentation"
       | 
         ## An annotation whose purpose is to provide commentary. 
         "commentary"
       | 
         ## An annotation whose purpose is to provide a source or attribution. 
         "attribution"
       | 
         ## An annotation whose purpose is to provide an introductory note. 
         "introductory-note")+
    }
  }
z3998.annoref =
  
  ## The annoref element represents a textual reference to an 
  ##  annotation . Although not as common as with footnotes and endnotes, the content or location in the document being annotated may be noted by a text referent (e.g., a superscripted symbol). By default, the text content of the annoref represents the link reference and is treated as document content. When superscripted numbers or symbols are instead used to identify the corresponding annotation, the 
  ##  annoref.value  attribute should be used. The annoref must be an empty element when attaching a value attribute; it it not permitted to include text content and a value attribute. The 
  ##  ref  attribute is used to establish the link between the annoref and its associated annotation. 
  element annoref {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    z3998.ref.attrib,
    z3998.annoref.value.attrib?,
    (empty
     | (z3998.span
        | text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:annoref"
         "\x{a}" ~
         "                "
         sch:report [
           test = "@value and (count(*|text()[normalize-space()]) > 0)"
           "The {value} attribute cannot be used on a non-empty {annoref}."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "not(@value) and (count(*|text()[normalize-space()]) = 0)"
           "An empty {annoref} element must include a {value} attribute."
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $ref in tokenize(current()/@ref, ' +') satisfies key('annotations', $ref)"
           "The IDREF(s) in the ref attribute must resolve to annotations. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:annoref"
         role = "warning"
         "\x{a}" ~
         "                "
         sch:report [
           role = "warning"
           test =
             "(count(node()[normalize-space()]) = 1) and child::default:sup"
           "Superscripted referents should be included in a {value} attribute, not as text content."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.annoref.value.attrib =
  
  ## The annoref value attribute provides the number or symbol that represents the current annotation reference. The value attribute allows any text string as an identifier. 
  attribute value { NonEmptyString.datatype }
z3998.aside.section =
  
  ## The aside element represents information supplementary to the main text and/or narrative flow. The Section variant is an adaptation for use with asides that contain structured content. An aside typically floats separate from the main text, often in a boxed or shaded region. The 
  ##  role  attribute optionally expresses the semantic nature of the aside. 
  element aside {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.aside.role.attrib?,
    z3998.h?,
    (z3998.section+ & z3998.pagebreak*)
    >> sch:rule [
         context = "default:aside"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The aside element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.aside.role.attrib =
  attribute role {
    list { CURIE.datatype+ }
  }
z3998.aside =
  
  ## The aside element represents information supplementary to the main text and/or narrative flow. The Block variant is an adaptation for use with asides that contain unstructured content. An aside typically floats separate from the main text, often in a boxed or shaded region. The 
  ##  role  attribute optionally expresses the semantic nature of the aside. 
  element aside {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.aside.role.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:aside"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The aside element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.caption =
  
  ## The caption element represents a short explanation or description accompanying a component of a publication. Captions most often occur in conjunction with illustrations, photographs, tables and diagrams. The 
  ##  ref  attribute identifies the component(s) to which the caption applies. 
  element caption {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.ref.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:caption"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(child::default:caption)"
           "The caption element must not contain child caption elements. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The caption element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.verse =
  
  ## The verse element represents a non-prose passage such as a poem, song, hymn etc., with or without metrical structure. The verse element consists of one or more 
  ##  lines  and may lines may be broken up into division such as stanzas and cantos using the 
  ##  lngroup  and 
  ##  verse.section  elements. 
  element verse {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (((z3998.h?
       & (z3998.transition
          | z3998.note.phrase
          | z3998.annotation.phrase
          | z3998.ln
          | z3998.lngroup
          | z3998.hd
          | z3998.pagebreak)+),
      z3998.verse.section*)
     | ((z3998.h?
         & (z3998.transition
            | z3998.note.phrase
            | z3998.annotation.phrase
            | z3998.ln
            | z3998.lngroup
            | z3998.hd
            | z3998.pagebreak)*),
        z3998.verse.section+))
  }
z3998.verse.section =
  
  ## The section element represents a major structural division of a 
  ##  verse , such as a canto. 
  element section {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.verse.role.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.depth.attrib?,
    (((z3998.h?
       & (z3998.transition
          | z3998.note.phrase
          | z3998.annotation.phrase
          | z3998.ln
          | z3998.lngroup
          | z3998.hd
          | z3998.pagebreak)+),
      z3998.verse.section*)
     | ((z3998.h?
         & (z3998.transition
            | z3998.note.phrase
            | z3998.annotation.phrase
            | z3998.ln
            | z3998.lngroup
            | z3998.hd
            | z3998.pagebreak)*),
        z3998.verse.section+))
  }
z3998.verse.role.attrib =
  attribute role {
    list {
      (CURIE.datatype
       | 
         ## A poem. 
         "poem"
       | 
         ## The text of a song. 
         "lyrics"
       | 
         ## A hymn. 
         "hymn"
       | 
         ## A song. 
         "song")+
    }
  }
z3998.description =
  
  ## The description element represents an alternate accessible description of an image, video, table, etc. The Block variant is an adaption for use embedding descriptions in other Block-layer elements and for grouping descriptions in Section-layer elements (for example, in the document 
  ##  head , where they can be referenced globally). The description element can either contain the text content of the description or reference an external file in which it can be found via the 
  ##  xlink.href  attribute. It is not permitted to mix both methods, however. To ensure the description can be rendered, the description element must not include descendant elements and attributes that require a description. 
  element description {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.description.role.attrib?,
    z3998.ref.attrib?,
    (xlink.href.attrib
     & xlink.type.attrib?
     & xlink.title.attrib?
     & xlink.show.attrib?
     & xlink.actuate.attrib?)?,
    (empty
     | (z3998.hd
        | z3998.block
        | z3998.p
        | z3998.transition
        | z3998.list
        | z3998.table
        | z3998.code.block
        | z3998.quote.block
        | z3998.citation.block
        | z3998.object.block
        | z3998.address
        | z3998.note
        | z3998.annotation
        | z3998.aside
        | z3998.caption
        | z3998.verse
        | z3998.description)+
     | (z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | text)+)
    >> sch:rule [
         context = "default:description"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "(normalize-space(.) or *) or @xlink:href"
           "The description element must either contain text data or point to an external resource using the xlink:href attribute. "
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "(normalize-space(.) or *) and @xlink:href"
           "The {description} element must not contain text data and also point to an external resource using the {xlink:href} attribute."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:description"
           "The {description} element must not contain descendant {description} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:object"
           "The {description} element must not contain descendant {object} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:table"
           "The {description} element must not contain descendant {table} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "descendant::*[namespace-uri(.) = 'http://www.w3.org/1998/Math/MathML']"
           "The {description} element must not contain descendant elements from the MathML feature grammar."
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:description[not(parent::default:object)]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "key('descrefs', current()/@xml:id) or key('descrefs', current()/@sel:selid)"
           "Every description element must be referenced by at least one element in the document. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:object"
         "\x{a}" ~
         "                "
         sch:report [
           test = "count(descendant::default:description) > 1"
           "The {object} element may contain only one child {description}."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "not(child::default:description) and descendant::default:description"
           "{description} elements cannot be nested inside the children of an {object} element."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "child::default:description and count(child::node()[normalize-space(.)]) > 1"
           "A single {description} element must be the only child of an {object} element when used."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.description.phrase =
  
  ## The description element represents an alternate accessible description of an image, video, table, etc. The description element can either contain the text content of the description or reference an external file in which it can be found via the 
  ##  xlink.href  attribute. It is not permitted to mix both methods, however. To ensure the description can be rendered, the description element must not include descendant elements and attributes that require a description. 
  element description {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.description.role.attrib?,
    z3998.ref.attrib,
    (xlink.href.attrib
     & xlink.type.attrib?
     & xlink.title.attrib?
     & xlink.show.attrib?
     & xlink.actuate.attrib?)?,
    (empty
     | (z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | text)+)
    >> sch:rule [
         context = "default:description"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "(normalize-space(.) or *) or @xlink:href"
           "The description element must either contain text data or point to an external resource using the xlink:href attribute. "
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "(normalize-space(.) or *) and @xlink:href"
           "The {description} element must not contain text data and also point to an external resource using the {xlink:href} attribute."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:description"
           "The {description} element must not contain descendant {description} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:object"
           "The {description} element must not contain descendant {object} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:table"
           "The {description} element must not contain descendant {table} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "descendant::*[namespace-uri(.) = 'http://www.w3.org/1998/Math/MathML']"
           "The {description} element must not contain descendant elements from the MathML feature grammar."
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:description[not(parent::default:object)]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "key('descrefs', current()/@xml:id) or key('descrefs', current()/@sel:selid)"
           "Every description element must be referenced by at least one element in the document. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:object"
         "\x{a}" ~
         "                "
         sch:report [
           test = "count(descendant::default:description) > 1"
           "The {object} element may contain only one child {description}."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "not(child::default:description) and descendant::default:description"
           "{description} elements cannot be nested inside the children of an {object} element."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "child::default:description and count(child::node()[normalize-space(.)]) > 1"
           "A single {description} element must be the only child of an {object} element when used."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.description.role.attrib =
  attribute role {
    list {
      (CURIE.datatype
       | 
         ## A structural description for a piece of content (e.g., a table structure summary). 
         "structure"
       | 
         ## A content description for a piece of content (e.g., an image description). 
         "content")+
    }
  }
z3998.description.text =
  
  ## The description element represents an alternate accessible description of an image, video, table, etc. The description element can either contain the text content of the description or reference an external file in which it can be found via the 
  ##  xlink.href  attribute. It is not permitted to mix both methods, however. To ensure the description can be rendered, the description element must not include descendant elements and attributes that require a description. 
  element description {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.description.role.attrib?,
    z3998.ref.attrib,
    (xlink.href.attrib
     & xlink.type.attrib?
     & xlink.title.attrib?
     & xlink.show.attrib?
     & xlink.actuate.attrib?)?,
    (empty
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:description"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "(normalize-space(.) or *) or @xlink:href"
           "The description element must either contain text data or point to an external resource using the xlink:href attribute. "
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "(normalize-space(.) or *) and @xlink:href"
           "The {description} element must not contain text data and also point to an external resource using the {xlink:href} attribute."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:description"
           "The {description} element must not contain descendant {description} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:object"
           "The {description} element must not contain descendant {object} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:table"
           "The {description} element must not contain descendant {table} elements."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "descendant::*[namespace-uri(.) = 'http://www.w3.org/1998/Math/MathML']"
           "The {description} element must not contain descendant elements from the MathML feature grammar."
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:description[not(parent::default:object)]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "key('descrefs', current()/@xml:id) or key('descrefs', current()/@sel:selid)"
           "Every description element must be referenced by at least one element in the document. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:object"
         "\x{a}" ~
         "                "
         sch:report [
           test = "count(descendant::default:description) > 1"
           "The {object} element may contain only one child {description}."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "not(child::default:description) and descendant::default:description"
           "{description} elements cannot be nested inside the children of an {object} element."
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "child::default:description and count(child::node()[normalize-space(.)]) > 1"
           "A single {description} element must be the only child of an {object} element when used."
         ]
         "\x{a}" ~
         "            "
       ]
  }

## The desc attribute establishes the connection between the current element and its associated accessible 
##  description (s). The desc attribute must contain one or more space separated references to the 
##  IDs  of the associated descriptions. Features may extend the use of this attribute, but not override the requirement that it resolve to a description. The 
##  Z39.98-2012 Content Selection feature , for example, provides a mechanism for pointing to a description based on the format being rendered. 
z3998.desc.attrib =
  attribute desc {
    list { NCName.datatype+ }
  }
  >> sch:rule [
       context = "default:*[@desc]"
       "\x{a}" ~
       "            "
       sch:assert [
         test =
           "every $descref in tokenize(current()/@desc,'\s+') satisfies key('descriptions', $descref)"
         "Every IDREF in the desc attribute must resolve to a description element. "
       ]
       "\x{a}" ~
       "        "
     ]
z3998.span =
  
  ## The span element represents an arbitrary phrase of text. The span element is similar to the 
  ##  block  element in that only acts a container for its child content. It is a semantically neutral element by default, but may express some other commonality between the elements such as formatting or language. To convey a semantic connection between the child content, the optional 
  ##  role  attribute must be attached. 
  element span {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.span.role.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:span"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The span element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.span.role.attrib =
  attribute role {
    list {
      (CURIE.datatype
       | 
         ## A formal second-person pronoun. 
         "v-form"
       | 
         ## An informal second-person pronoun. 
         "t-form")+
    }
  }
z3998.span.text =
  
  ## The span element represents an arbitrary phrase of text. The span element is similar to the 
  ##  block  element in that only acts a container for its child content. It is a semantically neutral element by default, but may express some other commonality between the elements such as formatting or language. To convey a semantic connection between the child content, the optional 
  ##  role  attribute must be attached. 
  element span {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.span.role.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:span"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The span element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.ln =
  
  ## The ln element represents a single line of text. The 
  ##  lnum  element can be added to the start of the ln to represent numbered lines. 
  element ln {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+
     & z3998.lnum?)
    >> sch:rule [
         context = "default:ln"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::default:ln)"
           "The ln element must not contain descendant ln elements. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ln element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.lnum =
  
  ## The lnum element represents the line number of the parent 
  ##  ln . Line numbers are a common convention in poetic works, legal texts and programming code. 
  element lnum {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:lnum"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The lnum element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.lngroup =
  
  ## The lngroup element represents a group of 
  ##  lines . 
  element lngroup {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.note.phrase*
     & z3998.annotation.phrase*
     & z3998.ln+
     & z3998.pagebreak*)
  }
z3998.pagebreak =
  
  ## The pagebreak element represents the location of a page break in a print source. The 
  ##  pagebreak.value  attribute optionally expresses a page number associated with the page. 
  element pagebreak {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    z3998.pagebreak.value.attrib?
  }
z3998.pagebreak.value.attrib =
  
  ## The pagebreak value attribute provides the numbering of the page immediately following the pagebreak element. The value attribute allows any text string as an identifier to accommodate Arabic, roman and other sequencing conventions. 
  attribute value { NonEmptyString.datatype }
z3998.s =
  
  ## The s element represents a grammatical and/or lexical sentence. 
  element s {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:s"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::default:s)"
           "The s element must not contain descendant s elements. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The s element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.w =
  
  ## The w element represents a single, possibly compound, lexical word. The 
  ##  role  attribute optionally expresses the semantic nature of the word. No implicit value is associated with the w element. 
  element w {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.w.role.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.wpart)+)
    >> sch:rule [
         context = "default:w"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The word element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.w.role.attrib =
  attribute role {
    list {
      (CURIE.datatype
       | 
         ## A formal second-person pronoun. 
         "v-form"
       | 
         ## A word created by the combination of two or more stems. 
         "compound"
       | 
         ## An informal second-person pronoun. 
         "t-form"
       | 
         ## An instance of a set of words with the same spelling but different etymologies and often pronunciations (e.g. bass the instrument and bass the fish). 
         "homograph"
       | 
         ## A word created from the merging of two other words (e.g. brunch from breakfast and lunch). 
         "portmanteau")+
    }
  }
z3998.wpart =
  
  ## The wpart element represents a segment of a word. The wpart element is typically used to distinguish the parts of a word (root, stem and affix), compound word, portmanteau or homograph. It can also be used in grammatical contexts to identify morphemes, graphemes and other divisions and boundaries within a word. The wpart element additionally can be used in place of soft hyphens to identify line ending break locations, if external formatting options are limited. The 
  ##  role  attribute optionally expresses the semantic nature of the word part. No implicit value is associated with the wpart element. 
  element wpart {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    (((text
       | z3998.object.text
       | z3998.sub
       | z3998.sup
       | z3998.char
       | z3998.span.text
       | z3998.emph.text
       | ssml.break
       | ssml.phoneme.text
       | ssml.prosody.text
       | ssml.say-as.text
       | ssml.sub.text
       | ssml.token.text
       | its-ruby
       | z3998.pagebreak)+
      | z3998.wpart)+)
    >> sch:rule [
         context = "default:wpart"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The wpart element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.abbr =
  
  ## The abbr element represents the abbreviated form of a phrase, term or name. The 
  ##  role  attribute optionally expresses whether the type of abbreviation. The 
  ##  expansion  and 
  ##  name  elements provide a mechanism for associating an abbreviation with its uncontracted form. When including an expansion, the ref attribute on the abbr element links the abbreviation to an expansion or name. The ref attribute can also be used to reference a 
  ##  definition  element when an explanatory definition of the abbreviation is also needed. 
  element abbr {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.abbr.role.attrib?,
    z3998.ref.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:abbr[@ref]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "some $exp in (//default:expansion, //default:name, //default:definition) satisfies current()/@ref eq $exp/@xml:id"
           "The ref attribute on an abbr element must resolve to an expansion, name or definition element. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:abbr"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The abbr element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.abbr.role.attrib =
  attribute role {
    list {
      (CURIE.datatype
       | 
         ## An abbreviation formed from the first part of a word. 
         "truncation"
       | 
         ## An abbreviation formed from initial letters of a name or expression, with each letter pronunced separately. 
         "initialism"
       | 
         ## An abbreviation formed from initial letters of a name or expression, pronounced as a word. 
         "acronym")+
    }
  }
z3998.expansion =
  
  ## The expansion element represents the fully expanded form of an 
  ##  abbreviation . The expansion element requires an xml:id attribute with a unique identifier for linking from the associated abbreviation. Expansions that are not part of the document content must be placed in the document 
  ##  head . 
  element expansion {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((z3998.span
      | text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:expansion"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::default:expansion)"
           "The expansion element must not contain descendant expansion elements. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The expansion element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.emph =
  
  ## The emph element represents an author's emphasis. Emphasis is not restricted to italicized text, but may constitute any of a variety of typographical or styling means used to distinguish text, such as bolding, underlining, coloring, etc. Nested emph elements indicate extra emphasized segments within an emphasized segment. 
  element emph {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((z3998.span
      | text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:emph"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The emph element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.emph.text =
  
  ## The emph element represents an author's emphasis. Emphasis is not restricted to italicized text, but may constitute any of a variety of typographical or styling means used to distinguish text, such as bolding, underlining, coloring, etc. Nested emph elements indicate extra emphasized segments within an emphasized segment. 
  element emph {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:emph"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The emph element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.time =
  
  ## The time element represents a calendar or clock-based statement of time. If the value of the time element is not in a machine-readable format, the 
  ##  time  attribute optionally allows the inclusion of an alternate representation. 
  element time {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    z3998.time.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:time"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::default:time)"
           "The time element must not contain descendant time elements. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The time element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.time.attrib =
  
  ## The time attribute contains a calendar or clock-based statement of time expressed in machine-readable form. When this attribute appears on the 
  ##  time  element, it contains an alternate rendition of the element's content. The time attribute value must be valid to the 
  ##  Time.datatype  datatype. 
  attribute time {
    xsd:gYear
    | xsd:gYearMonth
    | xsd:gMonthDay
    | xsd:gDay
    | xsd:gMonth
    | xsd:date
    | xsd:time
    | xsd:dateTime
    | TimeNoSeconds.datatype
  }
z3998.name =
  
  ## The name element represents particular instances of names, places and things (proper nouns). The 
  ##  role  attribute optionally expresses the semantic nature of the proper noun. No implicit value is associated with the name element. 
  element name {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.name.role.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.abbr
      | z3998.span.text)+)
    >> sch:rule [
         context = "default:name"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The name element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.name.role.attrib =
  attribute role {
    list {
      (CURIE.datatype
       | 
         ## The handwritten, digital or stamped representation of a person's name. 
         "signature"
       | 
         ## The name of a city, state, province, country or other geographic or political entity. . 
         "place"
       | 
         ## The name of a species, genus or other taxonomic classification. . 
         "taxonomy"
       | 
         ## The part of a personal name that distinguishes the person from a group of persons sharing the same surname. Also known as 'forename' or 'first name'. . 
         "given-name"
       | 
         ## A proper name identifying a person, often composed of a given name and a family name. 
         "personal-name"
       | 
         ## The part of a personal name that associates the person with a group of persons sharing the same surname. Also known as 'last name'. 
         "surname"
       | 
         ## The part of a personal name that signifies veneration, an official position or a professional or academic qualification. . 
         "name-title"
       | 
         ## The part of a personal name that indicates the family to which the person belongs. Often used in conjunction with a honorific. 
         "family-name"
       | 
         ## The name of a nationality, national group, or other designator of association. . 
         "nationality"
       | 
         ## The name of a religious, sporting, or other event, holiday or festival. . 
         "event"
       | 
         ## The name of an award or prize. . 
         "award"
       | 
         ## The brand name of a product, medication, etc. . 
         "product"
       | 
         ## The name of an organization, corporation, or other business entity. . 
         "organization")+
    }
  }
z3998.definition =
  
  ## The definition element represents a formal description of the meaning of a word, term, phrase, or other construct. The definition element requires an xml:id attribute with a unique identifier for linking from the associated term. Definitions that are not part of the document content may be placed in the document 
  ##  head . 
  element definition {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:definition"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The definition element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.term =
  
  ## The term element represents a word, or compound word, characterized by its particular use and context. The addition of a 
  ##  ref  attribute establishes a link to a definition. The value of the ref attribute must reference the xml:id of a 
  ##  definition  element 
  element term {
    z3998.ref.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((z3998.span
      | text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:term"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The term element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
    >> sch:rule [
         context = "default:term[@ref]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "some $def in //default:definition satisfies current()/@ref eq $def/@xml:id"
           "The ref attribute on a term element must resolve to a definition. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.d =
  
  ## The d element represents an instance of dialogue in a book, play, article or other document. Quotation marks should be included within the element if they must be retained in the file. The use of CSS for appending these characters is recommended, however, for the flexibility it allows to change the characters depending on the desired output. The 
  ##  ref  attribute can optionally be used to link an instance of dialogue to a character listed in a dramatis personae. 
  element d {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    z3998.ref.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:d"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::default:d)"
           "The d element must not contain descendant d elements. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The d element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.sub =
  
  ## The sub element represents instances of subscripted text. 
  element sub {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:sub"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The sub element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.sup =
  
  ## The sup element represents instances of superscripted text. 
  element sup {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:sup"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The sup element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.num =
  
  ## The num element represents a set of Arabic or Roman numerals that taken together indicate a single value or represent a single number in a standardized format. Examples of numbers include: cardinal and ordinal values, weights, measures, currency values, postal codes, telephone numbers, ISBN numbers, scores and results, etc. Where these values include units of measure or other symbols integral to their understanding, the units and symbols must be included as a part of the num element. The 
  ##  role  attribute optionally expresses the semantic nature of the number. If omitted, the implicit value cardinal is assumed. If the value of the num element is not in a machine-readable format, the 
  ##  num.value  attribute optionally allows the inclusion of an alternate representation. The MathML feature is intended for marking proper mathematical statements within documents and should be used in preference over the num element whenever equations, formulae or other formal mathematic constructs or operators are being marked. The num element must not be used to mark instances of dates and times. Refer to the 
  ##  time  element for more information. 
  element num {
    z3998.num.value.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.num.role.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:num"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The num element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.num.value.attrib =
  
  ## The value attribute provides the value of the num element in a machine-readable form. A processing agent's interpretation of the value depends on the specific type of numeral, as specified by the role attribute. 
  attribute value { NonEmptyString.datatype }
z3998.num.role.attrib =
  attribute role {
    list {
      (CURIE.datatype
       | 
         ## A whole number followed by a fraction with a numerator and denominator. 
         "mixed"
       | 
         ## A single value where the integral number is separated from the fractional value by a decimal point or comma. 
         "decimal"
       | 
         ## A currency value, including the denomination indicator. 
         "currency"
       | 
         ## A single value of measure, including units. 
         "measure"
       | 
         ## A single fraction with a numerator and denominator, and without a preceding whole number. 
         "fraction"
       | 
         ## An expression of the magnitude of two quantities relative to each other. 
         "ratio"
       | 
         ## A single value expressed using roman numerals. 
         "roman"
       | 
         ## A value indicating rank or position. 
         "ordinal"
       | 
         ## A phone number, including area code and international dialing code. 
         "phone"
       | 
         ## An International Standard Book Number. 
         "isbn"
       | 
         ## A value expressing the location of a point in n-dimensional space, including degree, minute and other indicators if specified. 
         "coordinate"
       | 
         ## A postal or zip code. 
         "postal-code"
       | 
         ## A single value that includes two or more sets of numbers separated by spaces. 
         "result"
       | 
         ## A value that defines proportionality to a whole, including percent sign if present. 
         "percentage"
       | 
         ## A value indicating quantity. 
         "cardinal"
       | 
         ## A single weight value, including units. 
         "weight")+
    }
  }
z3998.char =
  
  ## The char element represents a single instance of a special character or a character with no Unicode equivalent. The char element can contain either a single character or a 
  ##  object  tag, for characters and symbols that require special typesetting or display (e.g. ornamented initials at the start of chapters). 
  element char {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    (Character.datatype | z3998.object.text)
  }
xml.id.attrib =
  
  ## The xml:id attribute specifies a unique identifier for the element. No two elements in an xml document can have the same xml:id, including inside components that are appended to the primary document by xinclude statements or other means. The semantics of this attribute are defined by 
  ##  refXMLID . 
  attribute xml:id { ID.datatype }
xml.space.attrib =
  
  ## The xml:space attribute indicates whether the whitespace within an element is significant. The semantics of this attribute are defined by 
  ##  refXML . Refer to 
  ##  White Space Handling  for more information. 
  attribute xml:space {
    
    ## Signals that applications' default white-space processing modes are acceptable for this element. 
    "default"
    | 
      ## Signals the intent that applications preserve white space for this element. 
      "preserve"
  }
xml.base.attrib =
  
  ## The xml:base attribute specifies a base URI to use for resolving relative URI references, for instances where the base URI of the document or external entity is not appropriate. The semantics and behaviors of this attribute are defined by 
  ##  refXMLBase . 
  attribute xml:base { URI.datatype }
z3998.class.attrib =
  
  ## The class attribute provides the ability to express general classifying or commonality between elements. This attribute inherits all the fundamental properties of the (X)HTML class attribute and is usable in the context of 
  ##  CSS styling . The class attribute is not used to inflect semantics or structure on elements or their contents. Refer to the 
  ##  role  attribute for more information on how to layer semantic meaning on elements. 
  attribute class { NMTOKENS.datatype }
xml.lang.attrib =
  
  ## The xml:lang attribute identifies the natural or formal language in which the content is written. The semantics of this attribute are defined by 
  ##  refXML . Refer to 
  ##  Language Identification  for more information. 
  attribute xml:lang {
    xsd:language
    | xsd:string { length = "0" }
  }
its.dir.attrib =
  
  ## The its:dir attribute specifies the base writing direction of the content. If omitted, the implicit value ltr (left-to-right) is assumed. The semantics of this attribute are defined by 
  ##  refITS . Refer to 
  ##  Directionality  for more information. 
  attribute its:dir {
    
    ## The writing direction is left-to-right. This is the implicit value of this attribute. 
    "ltr"
    | 
      ## The writing direction is right-to-left. 
      "rtl"
    | 
      ## The writing direction is left-to-right override. 
      "lro"
    | 
      ## The writing direction is right-to-left override. 
      "rlo"
  }
its.translate.attrib =
  
  ## The its:translate attribute indicates whether the content of an element is translatable or not. If omitted, the implicit value yes is assumed. The semantics of this attribute are defined by 
  ##  refITS . Refer to 
  ##  Translate  for more information. 
  attribute its:translate {
    
    ## The content is translatable. This is the default value of this attribute. 
    "yes"
    | 
      ## The content is not translatable. 
      "no"
  }
xlink.href.attrib =
  
  ## Identifies a link target with a Legacy extended IRI (
  ##  LeIRI ) 
  attribute xlink:href { URI.datatype }
xlink.type.attrib =
  
  ## Identifies the XLink link type In any Z39.98-AI profile and as defined by XLink 
  ##  Simple Conformance , the xlink type simple is the implied xlink type, and does therefore not need to be expressed literally using the 
  ##  xlink.type  attribute. 
  attribute xlink:type {
    
    ## The XLink simple link type 
    "simple"
  }
xlink.title.attrib =
  
  ## Identifies the XLink title of the link. 
  attribute xlink:title { text }
xlink.show.attrib =
  
  ## Identifies the XLink show behavior of the link 
  attribute xlink:show {
    
    ## An application traversing to the ending resource should load it in a new window, frame, pane, or other relevant presentation context. 
    "new"
    | 
      ## An application traversing to the ending resource should load the resource in the same window, frame, pane, or other relevant presentation context in which the starting resource was loaded. 
      "replace"
    | 
      ## An application traversing to the ending resource should load its presentation in place of the presentation of the starting resource. 
      "embed"
    | 
      ## The behavior of an application traversing to the ending resource is unconstrained by XLink. The application should look for other markup present in the link to determine the appropriate behavior. 
      "other"
    | 
      ## The behavior of an application traversing to the ending resource is unconstrained by this specification. No other markup is present to help the application determine the appropriate behavior. 
      "none"
  }
xlink.actuate.attrib =
  
  ## Identifies the XLink actuate behavior of the link 
  attribute xlink:actuate {
    
    ## An application should traverse to the ending resource immediately on loading the starting resource. 
    "onLoad"
    | 
      ## An application should traverse from the starting resource to the ending resource only on a post-loading event triggered for the purpose of traversal. 
      "onRequest"
    | 
      ## The behavior of an application traversing to the ending resource is unconstrained by this specification. The application should look for other markup present in the link to determine the appropriate behavior. 
      "other"
    | 
      ## The behavior of an application traversing to the ending resource is unconstrained by this specification. No other markup is present to help the application determine the appropriate behavior. 
      "none"
  }
z3998.depth.attrib =
  
  ## The depth attribute specifies the nesting depth of the current element in relation to ancestors of the same type. An element's name alone does not infer an ancestral relationship; the usage context is equally important. For example, the depth of the first index 
  ##  section  is not influenced by the number of structural 
  ##  sections  that may enclose the index. The outermost ancestor has the implied depth value 0. 
  attribute depth { NonNegativeInteger.datatype }
rdfa.prefix.attrib =
  
  ## The prefix attribute associates RDFa vocabulary namespace prefixes and URIs, as defined in 
  ##  RDFa Core 1.1 . The prefix attribute may optionally be attached to the root 
  ##  document  element. Z39.98-AI profiles must not allow the attribute to be attached to any other element. The prefix attribute must not be used to redefine prefixes or URIs declared in the default context document for the profile. 
  attribute prefix { rdfa.prefix.attrib.content }
rdfa.prefix.attrib.content =
  xsd:normalizedString {
    pattern =
      "\s*([\i-[:]][\c-[:]]*: +[^ ]+)(\s+[\i-[:]][\c-[:]]*: +[^ ]+)*\s*"
  }
rdfa.about.attrib =
  
  ## The about attribute specifies the subject of a relationship. If not given, then the subject is the current document. 
  attribute about {
    URI.datatype
    >> sch:rule [
         context = "*[@about and starts-with(@about,'#')]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "exists(//*[@xml:id eq substring-after(current()/@about,'#')])"
           "The fragment URI in the about attribute must resolve to an ID in the document. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
rdfa.content.attrib =
  
  ## The content attribute specifies a string to use as an object for the 
  ##  rdfa.property  attribute. 
  attribute content { text }
rdfa.datatype.attrib =
  
  ## The datatype attribute specifies a datatype of the object of the 
  ##  rdfa.property  attribute (either in the content attribute, or the content of the element that the datatype attribute is on.) By default, data in the content attribute is of type string, and data in the content of an element has type xml:Literal. If datatype="" is used, then for the RDF the element content is stripped of markup, and is of type string. 
  attribute datatype {
    CURIE.datatype
    >> sch:rule [
         context = "*[@datatype]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $prefix in substring-before(@datatype, ':') satisfies (key('rdfprefix', $prefix) or key('rdfprofile', $prefix) or $prefix='')"
           "The datatype attribute contains an undeclared CURIE prefix. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
rdfa.typeof.attrib =
  
  ## The typeof attribute creates a blank node, which becomes the subject, and asserts that the current element contains relationships that match the given RDF type. 
  attribute typeof {
    list { CURIE.datatype+ }
    >> sch:rule [
         context = "*[@typeof]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $curie in tokenize(@typeof, '\s+') satisfies ( (every $prefix in substring-before($curie, ':') satisfies (key('rdfprefix', $prefix) or key('rdfprofile', $prefix) or $prefix='')))"
           "The typeof attribute contains an undeclared CURIE prefix. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
rdfa.property.attrib =
  
  ## The property attribute defines a relationship between the subject and either a string (if the 
  ##  rdfa.content  attribute is present) or the content of the element that the property attribute is on. 
  attribute property {
    list { CURIE.datatype+ }
    >> sch:rule [
         context = "*[@property]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $curie in tokenize(@property, '\s+') satisfies ( (every $prefix in substring-before($curie, ':') satisfies (key('rdfprefix', $prefix) or key('rdfprofile', $prefix) or $prefix='')))"
           "The property attribute contains an undeclared CURIE prefix. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
rdfa.rel.attrib =
  
  ## The rel attribute defines a relation between the subject and a URL given by the 
  ##  rdfa.resource  attribute. The 
  ##  rdfa.rev  attribute expresses the inverse relation. 
  attribute rel {
    list { CURIE.datatype+ }
    >> sch:rule [
         context = "*[@rel]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $curie in tokenize(@rel, '\s+') satisfies ( (every $prefix in substring-before($curie, ':') satisfies (key('rdfprefix', $prefix) or key('rdfprofile', $prefix) or $prefix='')))"
           "The rel attribute contains an undeclared CURIE prefix. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
rdfa.resource.attrib =
  
  ## The resource attribute specifies an object URI for the 
  ##  rdfa.rev  and 
  ##  rdfa.rel  attributes, if the attribute href is not present. 
  attribute resource { URI.datatype }
rdfa.rev.attrib =
  
  ## The rev attribute defines a relation between the subject and a URL given by the 
  ##  rdfa.resource  attribute. The 
  ##  rdfa.rel  attribute expresses the inverse relation. 
  attribute rev {
    list { CURIE.datatype+ }
    >> sch:rule [
         context = "*[@rev]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $curie in tokenize(@rev, '\s+') satisfies ( (every $prefix in substring-before($curie, ':') satisfies (key('rdfprefix', $prefix) or key('rdfprofile', $prefix) or $prefix='')))"
           "The rev attribute contains an undeclared CURIE prefix. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.role.attrib =
  
  ## The role attribute expresses a semantic inflection on the nature or purpose of its parent element. The attribute takes as its value one or more whitespace separated CURIEs 
  ##  refRDFa11 , that must be bound to one or more RDF vocabularies either defined in the RDFa initial context document or by the 
  ##  rdfa.prefix  attribute. The role attribute is intended to be functionally compatible with the WAI-PF role attribute (
  ##  refROLE ) in its expression of document metadata to improve the accessibility of documents marked up to Z39.98-AI profiles. 
  attribute role {
    list { CURIE.datatype+ }
    >> sch:rule [
         context = "*[@role]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "every $curie in tokenize(@role, '\s+') satisfies ( (every $prefix in substring-before($curie, ':') satisfies (key('rdfprefix', $prefix) or key('rdfprofile', $prefix) or $prefix='')))"
           "The role attribute contains an undeclared CURIE prefix. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.by.attrib =
  
  ## The by attribute expresses the contributor of an element to the document source, such as the author, editor, a republisher, etc. The by attribute allows a single CURIE as its value, which must be bound to an RDF property using the mechanism defined in 
  ##  CURIE . All descendants of an element that declares a by attribute value implicitly inherit that value. In the absence of an expressed relationship, the implicit value author is assumed. 
  attribute by {
    list {
      (CURIE.datatype
       | 
         ## An author of a work. 
         "author"
       | 
         ## The general editor of a work. 
         "general-editor"
       | 
         ## A translator of a work. 
         "translator"
       | 
         ## A commentator on a work. 
         "commentator"
       | 
         ## An editor of a work. 
         "editor"
       | 
         ## A republisher of a work. 
         "republisher")+
    }
  }
z3998.frontmatter =
  
  ## The frontmatter element groups the initial/preliminary sections of a document. Frontmatter typically consists of such sections as forewords, prefaces, acknowledgements, introductions, dedications, prologues, and tables of contents. Frontmatter pages are typically identified by the use of Roman numerals for their numbering, but numbering alone is not a reliable indicator (it is not uncommon for front matter to begin with Arabic number 1, for example). The table of contents may help identify frontmatter sections either through emphasized typeface and/or the use of line breaks between the front, body and back matter sections. 
  element frontmatter {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.section | z3998.toc | z3998.bibliography | z3998.glossary)+
  }
z3998.bodymatter =
  
  ## The bodymatter element groups the primary narrative of a document, as contrasted with preliminary material in frontmatter and supplementary information in backmatter. 
  element bodymatter {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.section+
  }
z3998.backmatter =
  
  ## The backmatter element groups supplementary sections at the end of a document. Backmatter typically consists of such sections as appendices, glossaries, bibliographies and indices. 
  element backmatter {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.section
     | z3998.toc
     | z3998.index
     | z3998.bibliography
     | z3998.glossary)+
  }
z3998.toc =
  
  ## The toc element represents a single table of contents in a document. The Section variant is an adaption for use when a table of contents represents a unique section of a work, such as the primary table of contents in the front matter of a book. The term "table of contents" is a generalization encompassing all of tables of contents, tables of figures, tables of maps and similar guides to the contents of a document. 
  element toc {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.h?
     & (z3998.toc.aside
        | z3998.block
        | z3998.hd
        | z3998.p
        | z3998.transition
        | z3998.object.block
        | z3998.pagebreak)*),
    ((z3998.toc.entry | z3998.toc.section)+
     & (z3998.hd | z3998.pagebreak)*)
  }
z3998.toc.block =
  
  ## The toc element represents a single table of contents in a document. The Block variant is an adaption for use when a table of contents is embedded within another sections, such as a mini table of contents to start a section. The term "table of contents" is a generalization encompassing all of tables of contents, tables of figures, tables of maps and similar guides to the contents of a document. 
  element toc {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    ((z3998.toc.entry | z3998.toc.section)+
     & (z3998.hd | z3998.pagebreak)*)
  }
z3998.toc.entry =
  
  ## The toc entry element represents a single entry in a 
  ##  table of contents , including all related child entries. A toc entry typically consists of the text on the leader line followed by an optional 
  ##  ref  element indicating the corresponding print page. The ref element can also be used to link the text of the entry directly to the location in the document when the table of contents or document does not include page numbers. The toc 
  ##  block  element is used to group all secondary information that falls below the leader line. It is not intended to group subentries, which should be included as children of the primary entry following the block.. 
  element entry {
    z3998.depth.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.rend.prefix.attrib?,
    (z3998.span
     | text
     | z3998.object.text
     | z3998.sub
     | z3998.sup
     | z3998.char
     | z3998.span.text
     | z3998.emph.text
     | ssml.break
     | ssml.phoneme.text
     | ssml.prosody.text
     | ssml.say-as.text
     | ssml.sub.text
     | ssml.token.text
     | its-ruby
     | z3998.ref
     | z3998.code.phrase
     | z3998.object.phrase
     | z3998.address.phrase
     | z3998.noteref
     | z3998.note.phrase
     | z3998.annoref
     | z3998.ln
     | z3998.s
     | z3998.w
     | z3998.w
     | z3998.expansion
     | z3998.abbr
     | z3998.emph
     | z3998.time
     | z3998.name
     | z3998.definition
     | z3998.term
     | z3998.d
     | z3998.num
     | z3998.rend.linebreak
     | ssml.break
     | ssml.phoneme
     | ssml.prosody
     | ssml.say-as
     | ssml.sub
     | ssml.token
     | math
     | z3998.select.phrase
     | xforms.input
     | xforms.textarea
     | xforms.secret
     | xforms.select1
     | xforms.select
     | xforms.range
     | z3998.pagebreak)+,
    z3998.ref?,
    z3998.toc.entry.elem.block?,
    ((z3998.toc.entry | z3998.pagebreak)*)
    >> sch:rule [
         context = "default:entry[ancestor::default:toc]"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The entry element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.toc.entry.elem.block =
  
  ## The toc block element is used to group any ancillary information that falls under an entry's leader line (not including subentries), such as descriptions or topic lists. 
  element block {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((z3998.block
      | z3998.hd
      | z3998.p
      | z3998.transition
      | z3998.object.block
      | z3998.list
      | z3998.toc.aside)+)
    >> sch:rule [
         context = "default:block"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The block element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.toc.section =
  
  ## The toc section element represents a subdivision of a 
  ##  table of contents . The toc section element is a specialization of the 
  ##  section  element that provides a content model to fit the unique requirements of table of contents divisions. 
  element section {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.h?
     & (z3998.toc.aside
        | z3998.block
        | z3998.hd
        | z3998.p
        | z3998.transition
        | z3998.object.block
        | z3998.pagebreak)*),
    ((z3998.toc.entry | z3998.toc.section)+
     & (z3998.hd | z3998.pagebreak)*)
  }
z3998.toc.aside =
  
  ## The toc aside element represents a separate block of information in a 
  ##  toc  table of contents from the main sections and entries. The toc aside element typically represents information in the margins of a print table of contents. 
  element aside {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (((z3998.hd
       | z3998.block
       | z3998.p
       | z3998.transition
       | z3998.list
       | z3998.table
       | z3998.code.block
       | z3998.quote.block
       | z3998.citation.block
       | z3998.object.block
       | z3998.address
       | z3998.note
       | z3998.annotation
       | z3998.aside
       | z3998.caption
       | z3998.verse
       | z3998.description
       | ssml.break
       | math
       | z3998.select.block
       | xforms.group
       | xforms.repeat
       | z3998.feature.description
       | z3998.pagebreak)+
      | (text
         | z3998.object.text
         | z3998.sub
         | z3998.sup
         | z3998.char
         | z3998.span.text
         | z3998.emph.text
         | ssml.break
         | ssml.phoneme.text
         | ssml.prosody.text
         | ssml.say-as.text
         | ssml.sub.text
         | ssml.token.text
         | its-ruby
         | z3998.span
         | z3998.ref
         | z3998.code.phrase
         | z3998.object.phrase
         | z3998.address.phrase
         | z3998.noteref
         | z3998.note.phrase
         | z3998.annoref
         | z3998.ln
         | z3998.s
         | z3998.w
         | z3998.w
         | z3998.expansion
         | z3998.abbr
         | z3998.emph
         | z3998.time
         | z3998.name
         | z3998.definition
         | z3998.term
         | z3998.d
         | z3998.num
         | z3998.rend.linebreak
         | z3998.quote.phrase
         | z3998.citation
         | z3998.annotation.phrase
         | ssml.break
         | ssml.phoneme
         | ssml.prosody
         | ssml.say-as
         | ssml.sub
         | ssml.token
         | math
         | z3998.select.phrase
         | xforms.input
         | xforms.textarea
         | xforms.secret
         | xforms.select1
         | xforms.select
         | xforms.range
         | z3998.pagebreak)+)
     & z3998.toc*)
    >> sch:rule [
         context = "default:aside"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The aside element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.cover =
  
  ## The cover element represents the complete cover or jacket of a print publication. 
  element cover {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.spine?,
    z3998.frontcover?,
    z3998.backcover?,
    (z3998.flaps?)
    >> sch:rule [
         context = "default:cover"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "count(*) > 0"
           "The cover element must contain at least one of its allowed children. "
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test = "descendant::default:pagebreak"
           "The {cover} element must contain descendant {pagebreak}s."
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.spine =
  
  ## The spine element represents the section of the cover that overlays the bound inner side of a publication. The spine typically contains the author/editor name(s), title and the publisher/imprint logo. Information on the spine is often truncated because of space constraints. 
  element spine {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    ((z3998.block
      | z3998.hd
      | z3998.p
      | z3998.transition
      | z3998.object.block)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range)+)
    >> sch:rule [
         context = "default:spine"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The spine element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.frontcover =
  
  ## The frontcover element represents all content and images contained on the inside and outside of the front cover. The front outside cover typically contains the title and/or author information overlaid on an illustration. The front inside cover may contain maps, additional books by the author, pricing, ISBN numbers, etc. 
  element frontcover {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.hd
     | z3998.block
     | z3998.p
     | z3998.transition
     | z3998.list
     | z3998.table
     | z3998.code.block
     | z3998.quote.block
     | z3998.citation.block
     | z3998.object.block
     | z3998.address
     | z3998.note
     | z3998.annotation
     | z3998.aside
     | z3998.caption
     | z3998.verse
     | z3998.description
     | ssml.break
     | math
     | z3998.select.block
     | xforms.group
     | xforms.repeat
     | z3998.feature.description)+
  }
z3998.backcover =
  
  ## The backcover element represents all content and images contained on the inside and outside of the back cover. The back covers typically contain biographical information about contributors, quotes, and a summary or description of the publication. 
  element backcover {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.hd
     | z3998.block
     | z3998.p
     | z3998.transition
     | z3998.list
     | z3998.table
     | z3998.code.block
     | z3998.quote.block
     | z3998.citation.block
     | z3998.object.block
     | z3998.address
     | z3998.note
     | z3998.annotation
     | z3998.aside
     | z3998.caption
     | z3998.verse
     | z3998.description
     | ssml.break
     | math
     | z3998.select.block
     | xforms.group
     | xforms.repeat
     | z3998.feature.description)+
  }
z3998.flaps =
  
  ## The flaps element represents all content and images contained on the front and back jacket flaps. If the content on the flaps is continued from the front to back flap, it should be merged and treated as unbroken. 
  element flaps {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.hd
     | z3998.block
     | z3998.p
     | z3998.transition
     | z3998.list
     | z3998.table
     | z3998.code.block
     | z3998.quote.block
     | z3998.citation.block
     | z3998.object.block
     | z3998.address
     | z3998.note
     | z3998.annotation
     | z3998.aside
     | z3998.caption
     | z3998.verse
     | z3998.description
     | ssml.break
     | math
     | z3998.select.block
     | xforms.group
     | xforms.repeat
     | z3998.feature.description)+
  }
z3998.index =
  
  ## The index element represents a topical reference section in a book. The 
  ##  entries  in an index may be grouped into 
  ##  sections  by topic or alphabetic letter. 
  element index {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.h?
     & (z3998.aside
        | z3998.block
        | z3998.hd
        | z3998.p
        | z3998.transition
        | z3998.object.block
        | z3998.pagebreak)*),
    (((z3998.index.entry+ & (z3998.hd | z3998.pagebreak)*),
      z3998.index.section*)
     | (z3998.index.entry*, z3998.index.section+))
  }
z3998.index.section =
  
  ## The index section element represents a major structural division of an 
  ##  index . The index section element is a specialization of the 
  ##  section  element that provides a content model to fit the unique requirements of index divisions. The republishing of documents often requires the insertion of content that was not a part of the original source document. For example, in the case of indexes, bibliographies and other ordered sections, this requirement may take the form of placeholder sections to mark gaps in the alphabetic list of entries. To indicate that an element presents content that is a deviation from the source, the 
  ##  role  attribute can be used with the value custom. No behaviors are defined for how a processing agent should handle sections so identified, however. 
  element section {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.h?
     & (z3998.aside
        | z3998.block
        | z3998.hd
        | z3998.p
        | z3998.transition
        | z3998.object.block
        | z3998.pagebreak)*),
    (((z3998.index.entry+ & (z3998.hd | z3998.pagebreak)*),
      z3998.index.section*)
     | (z3998.index.entry*, z3998.index.section+))
  }
z3998.index.entry =
  
  ## The index entry element represents a single entry in an 
  ##  index , including all related child entries. The 
  ##  ref  element can be used to link page number references back to the corresponding location in the document. 
  element entry {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.rend.prefix.attrib?,
    (text
     | z3998.object.text
     | z3998.sub
     | z3998.sup
     | z3998.char
     | z3998.span.text
     | z3998.emph.text
     | ssml.break
     | ssml.phoneme.text
     | ssml.prosody.text
     | ssml.say-as.text
     | ssml.sub.text
     | ssml.token.text
     | its-ruby
     | z3998.span
     | z3998.ref
     | z3998.code.phrase
     | z3998.object.phrase
     | z3998.address.phrase
     | z3998.noteref
     | z3998.note.phrase
     | z3998.annoref
     | z3998.ln
     | z3998.s
     | z3998.w
     | z3998.w
     | z3998.expansion
     | z3998.abbr
     | z3998.emph
     | z3998.time
     | z3998.name
     | z3998.definition
     | z3998.term
     | z3998.d
     | z3998.num
     | z3998.rend.linebreak
     | z3998.quote.phrase
     | z3998.citation
     | z3998.annotation.phrase
     | ssml.break
     | ssml.phoneme
     | ssml.prosody
     | ssml.say-as
     | ssml.sub
     | ssml.token
     | math
     | z3998.select.phrase
     | xforms.input
     | xforms.textarea
     | xforms.secret
     | xforms.select1
     | xforms.select
     | xforms.range
     | z3998.pagebreak)+,
    ((z3998.index.entry | z3998.pagebreak)*)
    >> sch:rule [
         context = "default:entry[ancestor::default:index]"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The entry element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.bibliography =
  
  ## The bibliography element represents a bibliography, discography, filmography or other bibliographic section. The 
  ##  entries  in an bibliography may be grouped into 
  ##  sections  by topic, work, alphabetic letter or other means. 
  element bibliography {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.h?
     & (z3998.aside
        | z3998.block
        | z3998.hd
        | z3998.p
        | z3998.transition
        | z3998.object.block
        | z3998.pagebreak)*),
    (((z3998.bibliography.entry+ & (z3998.hd | z3998.pagebreak)*),
      z3998.bibliography.section*)
     | (z3998.bibliography.entry*, z3998.bibliography.section+))
  }
z3998.bibliography.section =
  
  ## The bibliography section element represents a major structural division of a 
  ##  bibliography . The bibliography section element is a specialization of the 
  ##  section  element that provides a content model to fit the unique requirements of bibliographic divisions. The republishing of documents often requires the insertion of content that was not a part of the original source document. For example, in the case of indexes, bibliographies and other ordered sections, this requirement may take the form of placeholder sections to mark gaps in the alphabetic list of entries. To indicate that an element presents content that is a deviation from the source, the 
  ##  role  attribute can be used with the value custom. No behaviors are defined for how a processing agent should handle sections so identified, however. 
  element section {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.h?
     & (z3998.aside
        | z3998.block
        | z3998.hd
        | z3998.p
        | z3998.transition
        | z3998.object.block
        | z3998.pagebreak)*),
    (((z3998.bibliography.entry+ & (z3998.hd | z3998.pagebreak)*),
      z3998.bibliography.section*)
     | (z3998.bibliography.entry*, z3998.bibliography.section+))
  }
z3998.bibliography.entry =
  
  ## The bibliography entry element represents a single unique entry in a 
  ##  bibliography . 
  element entry {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:entry[ancestor::default:bibliography]"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The entry element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.glossary =
  
  ## The glossary element represents a glossary, pronunciation guide or other section that exclusively defines terms or phrases. The Section variant is an adaptation for use including terms and definitions that have been grouped as a separate section in a work, and where the glossary contains structured groups of entries by topic, letter of the alphabet, etc. The republishing of documents often requires the insertion of content that was not a part of the original source document. For example, in the case of indexes, bibliographies and other ordered sections, this requirement may take the form of placeholder sections to mark gaps in the alphabetic list of entries. To indicate that an element presents content that is a deviation from the source, the 
  ##  role  attribute can be used with the value custom. No behaviors are defined for how a processing agent should handle sections so identified, however. 
  element glossary {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.h?
     & (z3998.aside
        | z3998.block
        | z3998.hd
        | z3998.p
        | z3998.transition
        | z3998.object.block
        | z3998.pagebreak)*),
    (((z3998.glossary.entry+ & (z3998.hd | z3998.pagebreak)*),
      z3998.glossary.section*)
     | (z3998.glossary.entry*, z3998.glossary.section+))
  }
z3998.glossary.block =
  
  ## The glossary element represents a glossary, pronunciation guide or other section that exclusively defines terms or phrases. The Block variant is an adaptation for use including terms and definitions that have been grouped within the body of a work. 
  element glossary {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.glossary.entry+
  }
z3998.glossary.section =
  
  ## The glossary section element represents a major structural division in a 
  ##  glossary . The glossary section element is a specialization of the 
  ##  section  element. It provides a content model to fit the unique requirements of glossary divisions. 
  element section {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (z3998.h?
     & (z3998.aside
        | z3998.block
        | z3998.hd
        | z3998.p
        | z3998.transition
        | z3998.object.block
        | z3998.pagebreak)*),
    (((z3998.glossary.entry+ & (z3998.hd | z3998.pagebreak)*),
      z3998.glossary.section*)
     | (z3998.glossary.entry*, z3998.glossary.section+))
  }
z3998.glossary.entry =
  
  ## The glossary entry element represents a single unique entry in a 
  ##  glossary . A glossary entry must contain one or more 
  ##  term  elements and either one or more 
  ##  definition  elements or one or more 
  ##  ref  elements pointing to a definition. To facilitate the markup of glossaries, if an entry contains exactly one term and one definition an implicit association is assumed between them (i.e., the normal requirement to explicitly link the term to the definition by the 
  ##  ref  attribute does not apply). If the entry contains mutliple term or definition elements, then the explicit association of each is required. 
  element entry {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.rend.prefix.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "default:entry[ancestor::default:glossary]"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "descendant::default:term"
           "Each entry element must contain at least one term element. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "descendant::default:definition or descendant::default:ref"
           "Each entry element must contain at least one definition or ref element. "
         ]
         "\x{a}" ~
         "                "
         sch:report [
           test =
             "(count(descendant::default:term) > 1 or count(descendant::default:definition) > 1) and descendant::default:term[not(@ref)]"
           "Each {term} element must explicitly reference its {definition}(s) when more than one {term} or {definition} are included in the {entry}."
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "descendant::default:definition or descendant::default:ref[some $ref in tokenize(@ref, '\s+') satisfies //default:definition[@xml:id=$ref]]"
           "Each entry element must contain at least one definition or reference to a definition. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The entry element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.break =
  
  ## Controls the pausing or other prosodic boundaries between tokens. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:break {
    ssml.strength.attrib?, ssml.time.attrib?, xml.id.attrib?
  }
ssml.strength.attrib =
  
  ## Indicates the prosodic strength of the break in the speech output. Refer to 
  ##  SSML 1.1  for further information. 
  attribute strength {
    
    ## Indicates that no prosodic break boundary should be output. 
    "none"
    | "x-weak"
    | "weak"
    | "medium"
    | "strong"
    | "x-strong"
  }
ssml.time.attrib =
  
  ## Indicates the duration of a pause to be inserted in the output in seconds or milliseconds. Refer to 
  ##  SSML 1.1  for further information. 
  attribute time { CSS.TimeValue.datatype }
ssml.onlangfailure.attrib =
  
  ## Describes the desired behavior of a synthesis processor upon language speaking failure. The value of this attribute is inherited by descendants. Refer to 
  ##  SSML 1.1  for further information. 
  attribute ssml:onlangfailure {
    
    ## if a voice exists that can speak the language, the synthesis processor will switch to that voice and speak the content. Otherwise, the processor chooses another behavior (either ignoretext or ignorelang) 
    "changevoice"
    | 
      ## the synthesis processor will not attempt to render the text that is in the failed language. 
      "ignoretext"
    | 
      ## the synthesis processor will ignore the change in language and speak as if the content were in the previous language. 
      "ignorelang"
    | 
      ## processorchoice - the synthesis processor chooses the behavior (either changevoice, ignoretext, or ignorelang). 
      "processorchoice"
  }
ssml.phoneme =
  
  ## Provides a phonemic/phonetic pronunciation for the contained text. The phoneme element may be empty. However, it is recommended that the element contain human-readable text that can be used for non-spoken rendering of the document. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:phoneme {
    ssml.ph.attrib,
    ssml.alphabet.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:phoneme"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "not(descendant::ssml:*) and not(descendant::*[@ssml:*])"
           "The ssml:phoneme element must not have ssml namespace element or attribute descendants. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:phoneme element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.phoneme.text =
  
  ## Provides a phonemic/phonetic pronunciation for the contained text. The phoneme element may be empty. However, it is recommended that the element contain human-readable text that can be used for non-spoken rendering of the document. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:phoneme {
    ssml.ph.attrib,
    ssml.alphabet.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:phoneme"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "not(descendant::ssml:*) and not(descendant::*[@ssml:*])"
           "The ssml:phoneme element must not have ssml namespace element or attribute descendants. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:phoneme element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.ph.attrib =
  
  ## Specifies a phonemic/phonetic pronunciation for the text contained in the current element. Refer to 
  ##  SSML 1.1  for further information. 
  attribute ph { text }
ssml.alphabet.attrib =
  
  ## Specifies which phonemic/phonetic pronunciation alphabet is used in the 
  ##  ssml.ph  attribute. If omitted, the implicit value x-SAMPA is assumed. Refer to 
  ##  SSML 1.1  for further information. 
  attribute alphabet {
    
    ## The pronunciation alphabet is 
    ##  IPA . 
    "ipa"
    | 
      ## The pronunciation alphabet is 
      ##  X-SAMPA . 
      "x-SAMPA"
    | text
  }
ssml.prosody =
  
  ## Permits control of the pitch, speaking rate and volume of speech output. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:prosody {
    ssml.pitch.attrib?,
    ssml.contour.attrib?,
    ssml.range.attrib?,
    ssml.rate.attrib?,
    ssml.duration.attrib?,
    ssml.volume.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:prosody"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::ssml:prosody)"
           "The ssml:prosody element must not have ssml:prosody descendants. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:prosody element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.prosody.text =
  
  ## Permits control of the pitch, speaking rate and volume of speech output. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:prosody {
    ssml.pitch.attrib?,
    ssml.contour.attrib?,
    ssml.range.attrib?,
    ssml.rate.attrib?,
    ssml.duration.attrib?,
    ssml.volume.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:prosody"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::ssml:prosody)"
           "The ssml:prosody element must not have ssml:prosody descendants. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:prosody element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.pitch.attrib =
  
  ## Specifies the baseline pitch for the contained text. The labels x-low through x-high represent a sequence of monotonically non-decreasing pitch levels. Refer to 
  ##  SSML 1.1  for further information. 
  attribute pitch {
    "x-low"
    | "low"
    | "medium"
    | "high"
    | "x-high"
    | "default"
    | SSML.RelativeChange.datatype
    | SSML.PitchExpression.datatype
  }
ssml.contour.attrib =
  
  ## Sets the pitch contour for the contained text. Refer to 
  ##  SSML 1.1  for further information. 
  attribute contour { SSML.PitchContour.datatype }
ssml.range.attrib =
  
  ## Specifies the pitch range (variability) for the contained text. Refer to 
  ##  SSML 1.1  for further information. 
  attribute range {
    "x-low"
    | "low"
    | "medium"
    | "high"
    | "x-high"
    | "default"
    | SSML.RelativeChange.datatype
    | SSML.PitchExpression.datatype
  }
ssml.rate.attrib =
  
  ## Specifies a change in the speaking rate for the contained text. The values x-slow through x-fast represent a sequence of monotonically non-decreasing speaking rates. Refer to 
  ##  SSML 1.1  for further information. 
  attribute rate {
    "x-slow"
    | "slow"
    | "medium"
    | "fast"
    | "x-fast"
    | "default"
    | SSML.NonNegativePercentage.datatype
  }
ssml.duration.attrib =
  
  ## Specifies a value in seconds or milliseconds for the desired time to take to read the contained text. Refer to 
  ##  SSML 1.1  for further information. 
  attribute duration { CSS.TimeValue.datatype }
ssml.volume.attrib =
  
  ## Specifies the volume for the contained text. If omitted, the implicit value +0.0dB is assumed. Refer to 
  ##  SSML 1.1  for further information. 
  attribute volume {
    "silent"
    | "x-soft"
    | "soft"
    | "medium"
    | "loud"
    | "x-loud"
    | "default"
    | SSML.VolumeExpression.datatype
  }
ssml.say-as =
  
  ## Provides information on the type of text construct contained within the element to help specify the level of detail for rendering the contained text. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:say-as {
    ssml.interpret-as.attrib,
    ssml.format.attrib?,
    ssml.detail.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:say-as"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:say-as element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.say-as.text =
  
  ## Provides information on the type of text construct contained within the element to help specify the level of detail for rendering the contained text. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:say-as {
    ssml.interpret-as.attrib,
    ssml.format.attrib?,
    ssml.detail.attrib?,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:say-as"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:say-as element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.interpret-as.attrib =
  
  ## Indicates the content type of the contained text construct. Refer to 
  ##  SSML 1.1  for further information. 
  attribute interpret-as {
    
    ## Indicates that the contained text is a Gregorian calendar date. 
    "date"
    | 
      ## Indicates that the contained text is a time. 
      "time"
    | 
      ## Indicates that the contained text is a telephone number. 
      "telephone"
    | 
      ## Indicates that the enclosed text should be spoken as a series of alpha-numeric characters. 
      "characters"
    | 
      ## Indicates that the enclosed text is an integral or decimal number and should be spoken as a cardinal number (as opposed to an ordinal number or digit string). 
      "cardinal"
    | 
      ## Indicates that the enclosed text is an integral number and should be spoken as an ordinal number (as opposed to a cardinal number or digit string). 
      "ordinal"
  }
ssml.format.attrib =
  
  ## In addition to 
  ##  ssml.interpret-as , provides further hints on the precise formatting of the contained text for content types that may have ambiguous formats. Refer to 
  ##  SSML 1.1  for further information. 
  attribute format { text }
ssml.detail.attrib =
  
  ## Indicates the level of detail to be read aloud or rendered. Refer to 
  ##  SSML 1.1  for further information. 
  attribute detail { text }
ssml.sub =
  
  ## Indicates that the text in the alias attribute value replaces the contained text for pronunciation. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:sub {
    ssml.alias.attrib,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:sub"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:sub element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.alias.attrib =
  
  ## Specifies the string to be spoken instead of the string in the sub element. Refer to 
  ##  SSML 1.1  for further information. 
  attribute alias { text }
ssml.sub.text =
  
  ## Indicates that the text in the alias attribute value replaces the contained text for pronunciation. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:sub {
    ssml.alias.attrib,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:sub"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:sub element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.token =
  
  ## Indicates that the content is a token in order to to eliminate token (word) segmentation ambiguities of a synthesis processor. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:token {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:token"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:token element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.token.text =
  
  ## Indicates that the content is a token in order to to eliminate token (word) segmentation ambiguities of a synthesis processor. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:token {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "ssml:token"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The ssml:token element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.lexicon =
  
  ## Specifies a reference to a lexicon document. Refer to 
  ##  SSML 1.1  for further information. 
  element ssml:lexicon {
    ssml.lexicon.uri.attrib, xml.id.attrib, ssml.lexicon.type.attrib?
  }
ssml.lexicon.uri.attrib =
  
  ## Identifies the location of the lexicon document. Refer to 
  ##  SSML 1.1  for further information. 
  attribute uri { URI.datatype }
ssml.lexicon.type.attrib =
  
  ## Specifies the media type of the lexicon document. The implicit value of this attribute is application/pls+xml, the media type associated with the 
  ##  Pronunciation Lexicon Specification . Refer to 
  ##  SSML 1.1  for further information. 
  attribute type { "application/pls+xml" | MediaType.datatype }
ssml.ph.ns.attrib =
  
  ## Specifies a phonemic/phonetic pronunciation for the text contained in the current element. This attribute inherits the semantics of the 
  ##  ssml.ph  attribute on the SSML 
  ##  ssml.phoneme  element. Note that this attribute is namespace qualified and intended for use on non-SSML namespace elements, as opposed to the default (non-qualified) 
  ##  ssml.ph  attribute, which is only allowed on the 
  ##  ssml.phoneme  element. Consult 
  ##  Speech Synthesis Markup Language (SSML) Version 1.1  for further information. 
  attribute ssml:ph {
    text
    >> sch:rule [
         context = "*[@ssml:ph]"
         "\x{a}" ~
         "                "
         sch:assert [
           test =
             "not(descendant::ssml:phoneme) and not(descendant::*[@ssml:ph])"
           "Elements with the ssml:ph attribute element must not have ssml:phoneme descendants, nor descendants with the ssml:ph attribute. "
         ]
         "\x{a}" ~
         "                "
         sch:assert [
           test = "string-length(normalize-space(@ssml:ph)) > 0"
           "The ssml:ph attribute element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
ssml.alphabet.ns.attrib =
  
  ## Specifies which phonemic/phonetic pronunciation alphabet is used in the value of the 
  ##  ssml.ph.ns  attribute. Note that this attribute is namespace qualified and intended for use on non-SSML namespace elements in conjunction with the 
  ##  ssml.ph.ns  attribute. If omitted, the implicit value x-SAMPA is assumed. Consult 
  ##  Speech Synthesis Markup Language (SSML) Version 1.1  for further information. 
  attribute ssml:alphabet {
    
    ## The pronunciation alphabet is 
    ##  IPA . 
    "ipa"
    | 
      ## The pronunciation alphabet is 
      ##  X-SAMPA . 
      "x-SAMPA"
    | text
  }

## A relative change expression, as defined in 
##  relative change . 
SSML.RelativeChange.datatype =
  xsd:normalizedString {
    pattern = "[\-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)(%|st|Hz)"
  }

## A 
##  number  followed by the string 'Hz'. 
SSML.PitchExpression.datatype =
  xsd:normalizedString {
    pattern = "[\-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)Hz"
  }

## A pitch contour expression, as defined in 
##  pitch contour . 
SSML.PitchContour.datatype =
  xsd:normalizedString {
    pattern =
      "\(([\-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)%), ?([\-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)Hz)\)(,\s*\(([\-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)%), ?([\-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)Hz)\))*"
  }

## An unsigned 
##  number  immediately followed by "%", as defined in 
##  Non-negative percentage . 
SSML.NonNegativePercentage.datatype =
  xsd:normalizedString { pattern = "([0-9]+(\.[0-9]*)?|\.[0-9]+)%" }

## A 
##  number  preceded by "+" or "-" and immediately followed by "dB", as defined in 
##  prosody Element . 
SSML.VolumeExpression.datatype =
  xsd:normalizedString {
    pattern =
      "[\-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)dB|silent|((x-)?(loud|soft))|medium|default"
  }
its-ruby =
  
  ## The container for ruby markup declarations. The its:ruby element contains either 
  ##  simple  or 
  ##  complex  ruby markup. Refer to 
  ##  ITS Ruby  for further information. 
  
  ## Ruby markup. 
  element its:ruby {
    ((its-rb,
      (its-rt | (its-rp, its-rt, its-rp)))
     | (its-rbc, its-rtc, its-rtc?)),
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?
  }
its-rb =
  
  ## Contains the base text. Refer to 
  ##  ITS Ruby  for further information. 
  element its:rb {
    (text
     | z3998.object.text
     | z3998.sub
     | z3998.sup
     | z3998.char
     | z3998.span.text
     | z3998.emph.text
     | ssml.break
     | ssml.phoneme.text
     | ssml.prosody.text
     | ssml.say-as.text
     | ssml.sub.text
     | ssml.token.text
     | its-ruby
     | z3998.span
     | z3998.ref
     | z3998.code.phrase
     | z3998.object.phrase
     | z3998.address.phrase
     | z3998.noteref
     | z3998.note.phrase
     | z3998.annoref
     | z3998.ln
     | z3998.s
     | z3998.w
     | z3998.w
     | z3998.expansion
     | z3998.abbr
     | z3998.emph
     | z3998.time
     | z3998.name
     | z3998.definition
     | z3998.term
     | z3998.d
     | z3998.num
     | z3998.rend.linebreak
     | z3998.quote.phrase
     | z3998.citation
     | z3998.annotation.phrase
     | ssml.break
     | ssml.phoneme
     | ssml.prosody
     | ssml.say-as
     | ssml.sub
     | ssml.token
     | math
     | z3998.select.phrase
     | xforms.input
     | xforms.textarea
     | xforms.secret
     | xforms.select1
     | xforms.select
     | xforms.range
     | z3998.pagebreak)+,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?)
    >> sch:rule [
         context = "its:rb"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::its:ruby)"
           "The its:rb element must not contain its:ruby descendants. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
its-rt =
  
  ## Contains the ruby text. Refer to 
  ##  ITS Ruby  for further information. 
  element its:rt {
    (text
     | z3998.object.text
     | z3998.sub
     | z3998.sup
     | z3998.char
     | z3998.span.text
     | z3998.emph.text
     | ssml.break
     | ssml.phoneme.text
     | ssml.prosody.text
     | ssml.say-as.text
     | ssml.sub.text
     | ssml.token.text
     | its-ruby
     | z3998.span
     | z3998.ref
     | z3998.code.phrase
     | z3998.object.phrase
     | z3998.address.phrase
     | z3998.noteref
     | z3998.note.phrase
     | z3998.annoref
     | z3998.ln
     | z3998.s
     | z3998.w
     | z3998.w
     | z3998.expansion
     | z3998.abbr
     | z3998.emph
     | z3998.time
     | z3998.name
     | z3998.definition
     | z3998.term
     | z3998.d
     | z3998.num
     | z3998.rend.linebreak
     | z3998.quote.phrase
     | z3998.citation
     | z3998.annotation.phrase
     | ssml.break
     | ssml.phoneme
     | ssml.prosody
     | ssml.say-as
     | ssml.sub
     | ssml.token
     | math
     | z3998.select.phrase
     | xforms.input
     | xforms.textarea
     | xforms.secret
     | xforms.select1
     | xforms.select
     | xforms.range
     | z3998.pagebreak)+,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?,
    (its.rbspan.attrib?)
    >> sch:rule [
         context = "its:rt"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::its:ruby)"
           "The its:rt element must not contain its:ruby descendants. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
its.rbspan.attrib =
  
  ## Allows an its:rt element to span multiple its:rb elements in 
  ##  complex ruby markup . If omitted, the implicit value 1 is assumed.. Refer to 
  ##  ITS Ruby  for further information. 
  attribute rbspan {
    NonNegativeInteger.datatype
    >> sch:rule [
         context = "its:rt[@rbspan]"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(parent::its:ruby)"
           "The rbspan attribute must not be used on the its:rt element in simple ruby markup. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
its-rbc =
  
  ## Container for its:rb elements in 
  ##  complex ruby markup . Refer to 
  ##  ITS Ruby  for further information. 
  element its:rbc {
    its-rb+,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?
  }
its-rtc =
  
  ## Container for its:rt elements in 
  ##  complex ruby markup . Refer to 
  ##  ITS Ruby  for further information. 
  element its:rtc {
    its-rt+,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?
  }
its-rp =
  
  ## Ruby text beginning and end marker This element is used in the case of 
  ##  simple ruby markup  to specify characters that denote the beginning and end of ruby text when user agents do not have other ways to present ruby text distinctively from the base text. Refer to 
  ##  ITS Ruby  for further information. 
  element its:rp {
    text,
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?
  }
cn =
  element m:cn {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    cn.attributes.type?,
    base?,
    (text
     | mglyph
     | sep
     | mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction)*
  }
cn.attributes.type = attribute type { text }
semantics-ci =
  element m:semantics {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    cd?,
    name?,
    (ci | semantics-ci),
    (annotation | annotation-xml)*
  }
semantics-contexp =
  element m:semantics {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    cd?,
    name?,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity),
    (annotation | annotation-xml)*
  }
ci =
  element m:ci {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    ci.type?,
    (text
     | mglyph
     | mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction)*
  }
ci.type = attribute type { text }
csymbol =
  element m:csymbol {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    csymbol.attributes.type?,
    cd?,
    (text
     | mglyph
     | mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction)*
  }
csymbol.attributes.type = attribute type { text }
bvar = element m:bvar { (ci | semantics-ci) & degree? }
apply =
  element m:apply {
    xml.base.attrib?,
    xml.space.attrib?,
    ((semantics-contexp
      | cn
      | ci
      | csymbol
      | apply
      | bind
      | share
      | cerror
      | cbytes
      | share
      | cerror
      | cbytes
      | cs
      | piecewise
      | empty
      | interval
      | inverse
      | ident
      | domain
      | codomain
      | image
      | ln
      | log
      | moment
      | lambda
      | compose
      | quotient
      | divide
      | minus
      | power
      | rem
      | root
      | factorial
      | minus
      | root
      | abs
      | conjugate
      | arg
      | real
      | imaginary
      | floor
      | ceiling
      | exp
      | max
      | min
      | plus
      | times
      | gcd
      | lcm
      | and
      | or
      | xor
      | not
      | implies
      | equivalent
      | forall
      | exists
      | eq
      | gt
      | lt
      | geq
      | leq
      | neq
      | approx
      | factorof
      | tendsto
      | int
      | diff
      | partialdiff
      | divergence
      | grad
      | curl
      | laplacian
      | set
      | \list
      | union
      | intersect
      | cartesianproduct
      | in
      | notin
      | notsubset
      | notprsubset
      | setdiff
      | subset
      | prsubset
      | card
      | sum
      | product
      | limit
      | sin
      | cos
      | tan
      | sec
      | csc
      | cot
      | sinh
      | cosh
      | tanh
      | sech
      | csch
      | coth
      | arcsin
      | arccos
      | arctan
      | arccosh
      | arccot
      | arccoth
      | arccsc
      | arccsch
      | arcsec
      | arcsech
      | arcsinh
      | arctanh
      | mean
      | sdev
      | variance
      | median
      | mode
      | vector
      | matrix
      | matrixrow
      | determinant
      | transpose
      | selector
      | vectorproduct
      | scalarproduct
      | outerproduct
      | integers
      | reals
      | rationals
      | naturalnumbers
      | complexes
      | primes
      | emptyset
      | exponentiale
      | imaginaryi
      | notanumber
      | true
      | false
      | pi
      | eulergamma
      | infinity)+
     | ((semantics-contexp
         | cn
         | ci
         | csymbol
         | apply
         | bind
         | share
         | cerror
         | cbytes
         | share
         | cerror
         | cbytes
         | cs
         | piecewise
         | empty
         | interval
         | inverse
         | ident
         | domain
         | codomain
         | image
         | ln
         | log
         | moment
         | lambda
         | compose
         | quotient
         | divide
         | minus
         | power
         | rem
         | root
         | factorial
         | minus
         | root
         | abs
         | conjugate
         | arg
         | real
         | imaginary
         | floor
         | ceiling
         | exp
         | max
         | min
         | plus
         | times
         | gcd
         | lcm
         | and
         | or
         | xor
         | not
         | implies
         | equivalent
         | forall
         | exists
         | eq
         | gt
         | lt
         | geq
         | leq
         | neq
         | approx
         | factorof
         | tendsto
         | int
         | diff
         | partialdiff
         | divergence
         | grad
         | curl
         | laplacian
         | set
         | \list
         | union
         | intersect
         | cartesianproduct
         | in
         | notin
         | notsubset
         | notprsubset
         | setdiff
         | subset
         | prsubset
         | card
         | sum
         | product
         | limit
         | sin
         | cos
         | tan
         | sec
         | csc
         | cot
         | sinh
         | cosh
         | tanh
         | sech
         | csch
         | coth
         | arcsin
         | arccos
         | arctan
         | arccosh
         | arccot
         | arccoth
         | arccsc
         | arccsch
         | arcsec
         | arcsech
         | arcsinh
         | arctanh
         | mean
         | sdev
         | variance
         | median
         | mode
         | vector
         | matrix
         | matrixrow
         | determinant
         | transpose
         | selector
         | vectorproduct
         | scalarproduct
         | outerproduct
         | integers
         | reals
         | rationals
         | naturalnumbers
         | complexes
         | primes
         | emptyset
         | exponentiale
         | imaginaryi
         | notanumber
         | true
         | false
         | pi
         | eulergamma
         | infinity),
        bvar*,
        ((domainofapplication
          | condition
          | interval
          | (lowlimit, uplimit?))*
         | degree
         | momentabout
         | logbase)*,
        (semantics-contexp
         | cn
         | ci
         | csymbol
         | apply
         | bind
         | share
         | cerror
         | cbytes
         | share
         | cerror
         | cbytes
         | cs
         | piecewise
         | empty
         | interval
         | inverse
         | ident
         | domain
         | codomain
         | image
         | ln
         | log
         | moment
         | lambda
         | compose
         | quotient
         | divide
         | minus
         | power
         | rem
         | root
         | factorial
         | minus
         | root
         | abs
         | conjugate
         | arg
         | real
         | imaginary
         | floor
         | ceiling
         | exp
         | max
         | min
         | plus
         | times
         | gcd
         | lcm
         | and
         | or
         | xor
         | not
         | implies
         | equivalent
         | forall
         | exists
         | eq
         | gt
         | lt
         | geq
         | leq
         | neq
         | approx
         | factorof
         | tendsto
         | int
         | diff
         | partialdiff
         | divergence
         | grad
         | curl
         | laplacian
         | set
         | \list
         | union
         | intersect
         | cartesianproduct
         | in
         | notin
         | notsubset
         | notprsubset
         | setdiff
         | subset
         | prsubset
         | card
         | sum
         | product
         | limit
         | sin
         | cos
         | tan
         | sec
         | csc
         | cot
         | sinh
         | cosh
         | tanh
         | sech
         | csch
         | coth
         | arcsin
         | arccos
         | arctan
         | arccosh
         | arccot
         | arccoth
         | arccsc
         | arccsch
         | arcsec
         | arcsech
         | arcsinh
         | arctanh
         | mean
         | sdev
         | variance
         | median
         | mode
         | vector
         | matrix
         | matrixrow
         | determinant
         | transpose
         | selector
         | vectorproduct
         | scalarproduct
         | outerproduct
         | integers
         | reals
         | rationals
         | naturalnumbers
         | complexes
         | primes
         | emptyset
         | exponentiale
         | imaginaryi
         | notanumber
         | true
         | false
         | pi
         | eulergamma
         | infinity)*))
  }
bind =
  element m:bind {
    xml.base.attrib?,
    xml.space.attrib?,
    ((semantics-contexp
      | cn
      | ci
      | csymbol
      | apply
      | bind
      | share
      | cerror
      | cbytes
      | share
      | cerror
      | cbytes
      | cs
      | piecewise
      | empty
      | interval
      | inverse
      | ident
      | domain
      | codomain
      | image
      | ln
      | log
      | moment
      | lambda
      | compose
      | quotient
      | divide
      | minus
      | power
      | rem
      | root
      | factorial
      | minus
      | root
      | abs
      | conjugate
      | arg
      | real
      | imaginary
      | floor
      | ceiling
      | exp
      | max
      | min
      | plus
      | times
      | gcd
      | lcm
      | and
      | or
      | xor
      | not
      | implies
      | equivalent
      | forall
      | exists
      | eq
      | gt
      | lt
      | geq
      | leq
      | neq
      | approx
      | factorof
      | tendsto
      | int
      | diff
      | partialdiff
      | divergence
      | grad
      | curl
      | laplacian
      | set
      | \list
      | union
      | intersect
      | cartesianproduct
      | in
      | notin
      | notsubset
      | notprsubset
      | setdiff
      | subset
      | prsubset
      | card
      | sum
      | product
      | limit
      | sin
      | cos
      | tan
      | sec
      | csc
      | cot
      | sinh
      | cosh
      | tanh
      | sech
      | csch
      | coth
      | arcsin
      | arccos
      | arctan
      | arccosh
      | arccot
      | arccoth
      | arccsc
      | arccsch
      | arcsec
      | arcsech
      | arcsinh
      | arctanh
      | mean
      | sdev
      | variance
      | median
      | mode
      | vector
      | matrix
      | matrixrow
      | determinant
      | transpose
      | selector
      | vectorproduct
      | scalarproduct
      | outerproduct
      | integers
      | reals
      | rationals
      | naturalnumbers
      | complexes
      | primes
      | emptyset
      | exponentiale
      | imaginaryi
      | notanumber
      | true
      | false
      | pi
      | eulergamma
      | infinity)+
     | ((semantics-contexp
         | cn
         | ci
         | csymbol
         | apply
         | bind
         | share
         | cerror
         | cbytes
         | share
         | cerror
         | cbytes
         | cs
         | piecewise
         | empty
         | interval
         | inverse
         | ident
         | domain
         | codomain
         | image
         | ln
         | log
         | moment
         | lambda
         | compose
         | quotient
         | divide
         | minus
         | power
         | rem
         | root
         | factorial
         | minus
         | root
         | abs
         | conjugate
         | arg
         | real
         | imaginary
         | floor
         | ceiling
         | exp
         | max
         | min
         | plus
         | times
         | gcd
         | lcm
         | and
         | or
         | xor
         | not
         | implies
         | equivalent
         | forall
         | exists
         | eq
         | gt
         | lt
         | geq
         | leq
         | neq
         | approx
         | factorof
         | tendsto
         | int
         | diff
         | partialdiff
         | divergence
         | grad
         | curl
         | laplacian
         | set
         | \list
         | union
         | intersect
         | cartesianproduct
         | in
         | notin
         | notsubset
         | notprsubset
         | setdiff
         | subset
         | prsubset
         | card
         | sum
         | product
         | limit
         | sin
         | cos
         | tan
         | sec
         | csc
         | cot
         | sinh
         | cosh
         | tanh
         | sech
         | csch
         | coth
         | arcsin
         | arccos
         | arctan
         | arccosh
         | arccot
         | arccoth
         | arccsc
         | arccsch
         | arcsec
         | arcsech
         | arcsinh
         | arctanh
         | mean
         | sdev
         | variance
         | median
         | mode
         | vector
         | matrix
         | matrixrow
         | determinant
         | transpose
         | selector
         | vectorproduct
         | scalarproduct
         | outerproduct
         | integers
         | reals
         | rationals
         | naturalnumbers
         | complexes
         | primes
         | emptyset
         | exponentiale
         | imaginaryi
         | notanumber
         | true
         | false
         | pi
         | eulergamma
         | infinity),
        bvar*,
        ((domainofapplication
          | condition
          | interval
          | (lowlimit, uplimit?))*
         | degree
         | momentabout
         | logbase)*,
        (semantics-contexp
         | cn
         | ci
         | csymbol
         | apply
         | bind
         | share
         | cerror
         | cbytes
         | share
         | cerror
         | cbytes
         | cs
         | piecewise
         | empty
         | interval
         | inverse
         | ident
         | domain
         | codomain
         | image
         | ln
         | log
         | moment
         | lambda
         | compose
         | quotient
         | divide
         | minus
         | power
         | rem
         | root
         | factorial
         | minus
         | root
         | abs
         | conjugate
         | arg
         | real
         | imaginary
         | floor
         | ceiling
         | exp
         | max
         | min
         | plus
         | times
         | gcd
         | lcm
         | and
         | or
         | xor
         | not
         | implies
         | equivalent
         | forall
         | exists
         | eq
         | gt
         | lt
         | geq
         | leq
         | neq
         | approx
         | factorof
         | tendsto
         | int
         | diff
         | partialdiff
         | divergence
         | grad
         | curl
         | laplacian
         | set
         | \list
         | union
         | intersect
         | cartesianproduct
         | in
         | notin
         | notsubset
         | notprsubset
         | setdiff
         | subset
         | prsubset
         | card
         | sum
         | product
         | limit
         | sin
         | cos
         | tan
         | sec
         | csc
         | cot
         | sinh
         | cosh
         | tanh
         | sech
         | csch
         | coth
         | arcsin
         | arccos
         | arctan
         | arccosh
         | arccot
         | arccoth
         | arccsc
         | arccsch
         | arcsec
         | arcsech
         | arcsinh
         | arctanh
         | mean
         | sdev
         | variance
         | median
         | mode
         | vector
         | matrix
         | matrixrow
         | determinant
         | transpose
         | selector
         | vectorproduct
         | scalarproduct
         | outerproduct
         | integers
         | reals
         | rationals
         | naturalnumbers
         | complexes
         | primes
         | emptyset
         | exponentiale
         | imaginaryi
         | notanumber
         | true
         | false
         | pi
         | eulergamma
         | infinity)*))
  }
share = element m:share { xml.base.attrib?, xml.space.attrib?, src }
cerror =
  element m:cerror {
    xml.base.attrib?,
    xml.space.attrib?,
    csymbol,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)*
  }
cbytes =
  element m:cbytes {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    base64
  }
base64 = xsd:base64Binary
cs =
  element m:cs {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    text
  }
base = attribute base { text }
sep = element m:sep { empty }
domainofapplication =
  element m:domainofapplication {
    semantics-contexp
    | cn
    | ci
    | csymbol
    | apply
    | bind
    | share
    | cerror
    | cbytes
    | share
    | cerror
    | cbytes
    | cs
    | piecewise
    | empty
    | interval
    | inverse
    | ident
    | domain
    | codomain
    | image
    | ln
    | log
    | moment
    | lambda
    | compose
    | quotient
    | divide
    | minus
    | power
    | rem
    | root
    | factorial
    | minus
    | root
    | abs
    | conjugate
    | arg
    | real
    | imaginary
    | floor
    | ceiling
    | exp
    | max
    | min
    | plus
    | times
    | gcd
    | lcm
    | and
    | or
    | xor
    | not
    | implies
    | equivalent
    | forall
    | exists
    | eq
    | gt
    | lt
    | geq
    | leq
    | neq
    | approx
    | factorof
    | tendsto
    | int
    | diff
    | partialdiff
    | divergence
    | grad
    | curl
    | laplacian
    | set
    | \list
    | union
    | intersect
    | cartesianproduct
    | in
    | notin
    | notsubset
    | notprsubset
    | setdiff
    | subset
    | prsubset
    | card
    | sum
    | product
    | limit
    | sin
    | cos
    | tan
    | sec
    | csc
    | cot
    | sinh
    | cosh
    | tanh
    | sech
    | csch
    | coth
    | arcsin
    | arccos
    | arctan
    | arccosh
    | arccot
    | arccoth
    | arccsc
    | arccsch
    | arcsec
    | arcsech
    | arcsinh
    | arctanh
    | mean
    | sdev
    | variance
    | median
    | mode
    | vector
    | matrix
    | matrixrow
    | determinant
    | transpose
    | selector
    | vectorproduct
    | scalarproduct
    | outerproduct
    | integers
    | reals
    | rationals
    | naturalnumbers
    | complexes
    | primes
    | emptyset
    | exponentiale
    | imaginaryi
    | notanumber
    | true
    | false
    | pi
    | eulergamma
    | infinity
  }
condition =
  element m:condition {
    semantics-contexp
    | cn
    | ci
    | csymbol
    | apply
    | bind
    | share
    | cerror
    | cbytes
    | share
    | cerror
    | cbytes
    | cs
    | piecewise
    | empty
    | interval
    | inverse
    | ident
    | domain
    | codomain
    | image
    | ln
    | log
    | moment
    | lambda
    | compose
    | quotient
    | divide
    | minus
    | power
    | rem
    | root
    | factorial
    | minus
    | root
    | abs
    | conjugate
    | arg
    | real
    | imaginary
    | floor
    | ceiling
    | exp
    | max
    | min
    | plus
    | times
    | gcd
    | lcm
    | and
    | or
    | xor
    | not
    | implies
    | equivalent
    | forall
    | exists
    | eq
    | gt
    | lt
    | geq
    | leq
    | neq
    | approx
    | factorof
    | tendsto
    | int
    | diff
    | partialdiff
    | divergence
    | grad
    | curl
    | laplacian
    | set
    | \list
    | union
    | intersect
    | cartesianproduct
    | in
    | notin
    | notsubset
    | notprsubset
    | setdiff
    | subset
    | prsubset
    | card
    | sum
    | product
    | limit
    | sin
    | cos
    | tan
    | sec
    | csc
    | cot
    | sinh
    | cosh
    | tanh
    | sech
    | csch
    | coth
    | arcsin
    | arccos
    | arctan
    | arccosh
    | arccot
    | arccoth
    | arccsc
    | arccsch
    | arcsec
    | arcsech
    | arcsinh
    | arctanh
    | mean
    | sdev
    | variance
    | median
    | mode
    | vector
    | matrix
    | matrixrow
    | determinant
    | transpose
    | selector
    | vectorproduct
    | scalarproduct
    | outerproduct
    | integers
    | reals
    | rationals
    | naturalnumbers
    | complexes
    | primes
    | emptyset
    | exponentiale
    | imaginaryi
    | notanumber
    | true
    | false
    | pi
    | eulergamma
    | infinity
  }
uplimit =
  element m:uplimit {
    semantics-contexp
    | cn
    | ci
    | csymbol
    | apply
    | bind
    | share
    | cerror
    | cbytes
    | share
    | cerror
    | cbytes
    | cs
    | piecewise
    | empty
    | interval
    | inverse
    | ident
    | domain
    | codomain
    | image
    | ln
    | log
    | moment
    | lambda
    | compose
    | quotient
    | divide
    | minus
    | power
    | rem
    | root
    | factorial
    | minus
    | root
    | abs
    | conjugate
    | arg
    | real
    | imaginary
    | floor
    | ceiling
    | exp
    | max
    | min
    | plus
    | times
    | gcd
    | lcm
    | and
    | or
    | xor
    | not
    | implies
    | equivalent
    | forall
    | exists
    | eq
    | gt
    | lt
    | geq
    | leq
    | neq
    | approx
    | factorof
    | tendsto
    | int
    | diff
    | partialdiff
    | divergence
    | grad
    | curl
    | laplacian
    | set
    | \list
    | union
    | intersect
    | cartesianproduct
    | in
    | notin
    | notsubset
    | notprsubset
    | setdiff
    | subset
    | prsubset
    | card
    | sum
    | product
    | limit
    | sin
    | cos
    | tan
    | sec
    | csc
    | cot
    | sinh
    | cosh
    | tanh
    | sech
    | csch
    | coth
    | arcsin
    | arccos
    | arctan
    | arccosh
    | arccot
    | arccoth
    | arccsc
    | arccsch
    | arcsec
    | arcsech
    | arcsinh
    | arctanh
    | mean
    | sdev
    | variance
    | median
    | mode
    | vector
    | matrix
    | matrixrow
    | determinant
    | transpose
    | selector
    | vectorproduct
    | scalarproduct
    | outerproduct
    | integers
    | reals
    | rationals
    | naturalnumbers
    | complexes
    | primes
    | emptyset
    | exponentiale
    | imaginaryi
    | notanumber
    | true
    | false
    | pi
    | eulergamma
    | infinity
  }
lowlimit =
  element m:lowlimit {
    semantics-contexp
    | cn
    | ci
    | csymbol
    | apply
    | bind
    | share
    | cerror
    | cbytes
    | share
    | cerror
    | cbytes
    | cs
    | piecewise
    | empty
    | interval
    | inverse
    | ident
    | domain
    | codomain
    | image
    | ln
    | log
    | moment
    | lambda
    | compose
    | quotient
    | divide
    | minus
    | power
    | rem
    | root
    | factorial
    | minus
    | root
    | abs
    | conjugate
    | arg
    | real
    | imaginary
    | floor
    | ceiling
    | exp
    | max
    | min
    | plus
    | times
    | gcd
    | lcm
    | and
    | or
    | xor
    | not
    | implies
    | equivalent
    | forall
    | exists
    | eq
    | gt
    | lt
    | geq
    | leq
    | neq
    | approx
    | factorof
    | tendsto
    | int
    | diff
    | partialdiff
    | divergence
    | grad
    | curl
    | laplacian
    | set
    | \list
    | union
    | intersect
    | cartesianproduct
    | in
    | notin
    | notsubset
    | notprsubset
    | setdiff
    | subset
    | prsubset
    | card
    | sum
    | product
    | limit
    | sin
    | cos
    | tan
    | sec
    | csc
    | cot
    | sinh
    | cosh
    | tanh
    | sech
    | csch
    | coth
    | arcsin
    | arccos
    | arctan
    | arccosh
    | arccot
    | arccoth
    | arccsc
    | arccsch
    | arcsec
    | arcsech
    | arcsinh
    | arctanh
    | mean
    | sdev
    | variance
    | median
    | mode
    | vector
    | matrix
    | matrixrow
    | determinant
    | transpose
    | selector
    | vectorproduct
    | scalarproduct
    | outerproduct
    | integers
    | reals
    | rationals
    | naturalnumbers
    | complexes
    | primes
    | emptyset
    | exponentiale
    | imaginaryi
    | notanumber
    | true
    | false
    | pi
    | eulergamma
    | infinity
  }
degree =
  element m:degree {
    semantics-contexp
    | cn
    | ci
    | csymbol
    | apply
    | bind
    | share
    | cerror
    | cbytes
    | share
    | cerror
    | cbytes
    | cs
    | piecewise
    | empty
    | interval
    | inverse
    | ident
    | domain
    | codomain
    | image
    | ln
    | log
    | moment
    | lambda
    | compose
    | quotient
    | divide
    | minus
    | power
    | rem
    | root
    | factorial
    | minus
    | root
    | abs
    | conjugate
    | arg
    | real
    | imaginary
    | floor
    | ceiling
    | exp
    | max
    | min
    | plus
    | times
    | gcd
    | lcm
    | and
    | or
    | xor
    | not
    | implies
    | equivalent
    | forall
    | exists
    | eq
    | gt
    | lt
    | geq
    | leq
    | neq
    | approx
    | factorof
    | tendsto
    | int
    | diff
    | partialdiff
    | divergence
    | grad
    | curl
    | laplacian
    | set
    | \list
    | union
    | intersect
    | cartesianproduct
    | in
    | notin
    | notsubset
    | notprsubset
    | setdiff
    | subset
    | prsubset
    | card
    | sum
    | product
    | limit
    | sin
    | cos
    | tan
    | sec
    | csc
    | cot
    | sinh
    | cosh
    | tanh
    | sech
    | csch
    | coth
    | arcsin
    | arccos
    | arctan
    | arccosh
    | arccot
    | arccoth
    | arccsc
    | arccsch
    | arcsec
    | arcsech
    | arcsinh
    | arctanh
    | mean
    | sdev
    | variance
    | median
    | mode
    | vector
    | matrix
    | matrixrow
    | determinant
    | transpose
    | selector
    | vectorproduct
    | scalarproduct
    | outerproduct
    | integers
    | reals
    | rationals
    | naturalnumbers
    | complexes
    | primes
    | emptyset
    | exponentiale
    | imaginaryi
    | notanumber
    | true
    | false
    | pi
    | eulergamma
    | infinity
  }
momentabout =
  element m:momentabout {
    semantics-contexp
    | cn
    | ci
    | csymbol
    | apply
    | bind
    | share
    | cerror
    | cbytes
    | share
    | cerror
    | cbytes
    | cs
    | piecewise
    | empty
    | interval
    | inverse
    | ident
    | domain
    | codomain
    | image
    | ln
    | log
    | moment
    | lambda
    | compose
    | quotient
    | divide
    | minus
    | power
    | rem
    | root
    | factorial
    | minus
    | root
    | abs
    | conjugate
    | arg
    | real
    | imaginary
    | floor
    | ceiling
    | exp
    | max
    | min
    | plus
    | times
    | gcd
    | lcm
    | and
    | or
    | xor
    | not
    | implies
    | equivalent
    | forall
    | exists
    | eq
    | gt
    | lt
    | geq
    | leq
    | neq
    | approx
    | factorof
    | tendsto
    | int
    | diff
    | partialdiff
    | divergence
    | grad
    | curl
    | laplacian
    | set
    | \list
    | union
    | intersect
    | cartesianproduct
    | in
    | notin
    | notsubset
    | notprsubset
    | setdiff
    | subset
    | prsubset
    | card
    | sum
    | product
    | limit
    | sin
    | cos
    | tan
    | sec
    | csc
    | cot
    | sinh
    | cosh
    | tanh
    | sech
    | csch
    | coth
    | arcsin
    | arccos
    | arctan
    | arccosh
    | arccot
    | arccoth
    | arccsc
    | arccsch
    | arcsec
    | arcsech
    | arcsinh
    | arctanh
    | mean
    | sdev
    | variance
    | median
    | mode
    | vector
    | matrix
    | matrixrow
    | determinant
    | transpose
    | selector
    | vectorproduct
    | scalarproduct
    | outerproduct
    | integers
    | reals
    | rationals
    | naturalnumbers
    | complexes
    | primes
    | emptyset
    | exponentiale
    | imaginaryi
    | notanumber
    | true
    | false
    | pi
    | eulergamma
    | infinity
  }
logbase =
  element m:logbase {
    semantics-contexp
    | cn
    | ci
    | csymbol
    | apply
    | bind
    | share
    | cerror
    | cbytes
    | share
    | cerror
    | cbytes
    | cs
    | piecewise
    | empty
    | interval
    | inverse
    | ident
    | domain
    | codomain
    | image
    | ln
    | log
    | moment
    | lambda
    | compose
    | quotient
    | divide
    | minus
    | power
    | rem
    | root
    | factorial
    | minus
    | root
    | abs
    | conjugate
    | arg
    | real
    | imaginary
    | floor
    | ceiling
    | exp
    | max
    | min
    | plus
    | times
    | gcd
    | lcm
    | and
    | or
    | xor
    | not
    | implies
    | equivalent
    | forall
    | exists
    | eq
    | gt
    | lt
    | geq
    | leq
    | neq
    | approx
    | factorof
    | tendsto
    | int
    | diff
    | partialdiff
    | divergence
    | grad
    | curl
    | laplacian
    | set
    | \list
    | union
    | intersect
    | cartesianproduct
    | in
    | notin
    | notsubset
    | notprsubset
    | setdiff
    | subset
    | prsubset
    | card
    | sum
    | product
    | limit
    | sin
    | cos
    | tan
    | sec
    | csc
    | cot
    | sinh
    | cosh
    | tanh
    | sech
    | csch
    | coth
    | arcsin
    | arccos
    | arctan
    | arccosh
    | arccot
    | arccoth
    | arccsc
    | arccsch
    | arcsec
    | arcsech
    | arcsinh
    | arctanh
    | mean
    | sdev
    | variance
    | median
    | mode
    | vector
    | matrix
    | matrixrow
    | determinant
    | transpose
    | selector
    | vectorproduct
    | scalarproduct
    | outerproduct
    | integers
    | reals
    | rationals
    | naturalnumbers
    | complexes
    | primes
    | emptyset
    | exponentiale
    | imaginaryi
    | notanumber
    | true
    | false
    | pi
    | eulergamma
    | infinity
  }
type = attribute type { text }
order = attribute order { "numeric" | "lexicographic" }
closure = attribute closure { text }
piecewise =
  element m:piecewise {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    (piece* & otherwise?)
  }
piece =
  element m:piece {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity),
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)
  }
otherwise =
  element m:otherwise {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)
  }
interval =
  element m:interval {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    closure?,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity),
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)
  }
inverse =
  element m:inverse {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
ident =
  element m:ident {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
domain =
  element m:domain {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
codomain =
  element m:codomain {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
image =
  element m:image {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
ln =
  element m:ln {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
log =
  element m:log {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
moment =
  element m:moment {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
lambda =
  element m:lambda {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    bvar*,
    (domainofapplication
     | condition
     | interval
     | (lowlimit, uplimit?))*,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)
  }
compose =
  element m:compose {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
quotient =
  element m:quotient {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
divide =
  element m:divide {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
minus =
  element m:minus {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
power =
  element m:power {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
rem =
  element m:rem {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
root =
  element m:root {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
factorial =
  element m:factorial {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
abs =
  element m:abs {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
conjugate =
  element m:conjugate {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arg =
  element m:arg {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
real =
  element m:real {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
imaginary =
  element m:imaginary {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
floor =
  element m:floor {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
ceiling =
  element m:ceiling {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
exp =
  element m:exp {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
max =
  element m:max {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
min =
  element m:min {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
plus =
  element m:plus {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
times =
  element m:times {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
gcd =
  element m:gcd {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
lcm =
  element m:lcm {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
and =
  element m:and {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
or =
  element m:or {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
xor =
  element m:xor {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
not =
  element m:not {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
implies =
  element m:implies {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
equivalent =
  element m:equivalent {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
forall =
  element m:forall {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
exists =
  element m:exists {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
eq =
  element m:eq {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
gt =
  element m:gt {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
lt =
  element m:lt {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
geq =
  element m:geq {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
leq =
  element m:leq {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
neq =
  element m:neq {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
approx =
  element m:approx {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
factorof =
  element m:factorof {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
tendsto =
  element m:tendsto {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    type?
  }
int =
  element m:int {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
diff =
  element m:diff {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
partialdiff =
  element m:partialdiff {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
divergence =
  element m:divergence {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
grad =
  element m:grad {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
curl =
  element m:curl {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
laplacian =
  element m:laplacian {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
set =
  element m:set {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    type?,
    bvar*,
    (domainofapplication
     | condition
     | interval
     | (lowlimit, uplimit?))*,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)*
  }
\list =
  element m:list {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    order?,
    bvar*,
    (domainofapplication
     | condition
     | interval
     | (lowlimit, uplimit?))*,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)*
  }
union =
  element m:union {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
intersect =
  element m:intersect {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
cartesianproduct =
  element m:cartesianproduct {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
in =
  element m:in {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
notin =
  element m:notin {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
notsubset =
  element m:notsubset {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
notprsubset =
  element m:notprsubset {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
setdiff =
  element m:setdiff {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
subset =
  element m:subset {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
prsubset =
  element m:prsubset {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
card =
  element m:card {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
sum =
  element m:sum {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
product =
  element m:product {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
limit =
  element m:limit {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
sin =
  element m:sin {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
cos =
  element m:cos {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
tan =
  element m:tan {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
sec =
  element m:sec {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
csc =
  element m:csc {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
cot =
  element m:cot {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
sinh =
  element m:sinh {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
cosh =
  element m:cosh {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
tanh =
  element m:tanh {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
sech =
  element m:sech {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
csch =
  element m:csch {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
coth =
  element m:coth {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arcsin =
  element m:arcsin {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arccos =
  element m:arccos {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arctan =
  element m:arctan {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arccosh =
  element m:arccosh {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arccot =
  element m:arccot {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arccoth =
  element m:arccoth {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arccsc =
  element m:arccsc {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arccsch =
  element m:arccsch {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arcsec =
  element m:arcsec {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arcsech =
  element m:arcsech {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arcsinh =
  element m:arcsinh {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
arctanh =
  element m:arctanh {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
mean =
  element m:mean {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
sdev =
  element m:sdev {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
variance =
  element m:variance {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
median =
  element m:median {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
mode =
  element m:mode {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
vector =
  element m:vector {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    bvar*,
    (domainofapplication
     | condition
     | interval
     | (lowlimit, uplimit?))*,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)*
  }
matrix =
  element m:matrix {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    bvar*,
    (domainofapplication
     | condition
     | interval
     | (lowlimit, uplimit?))*,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)*
  }
matrixrow =
  element m:matrixrow {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    bvar*,
    (domainofapplication
     | condition
     | interval
     | (lowlimit, uplimit?))*,
    (semantics-contexp
     | cn
     | ci
     | csymbol
     | apply
     | bind
     | share
     | cerror
     | cbytes
     | share
     | cerror
     | cbytes
     | cs
     | piecewise
     | empty
     | interval
     | inverse
     | ident
     | domain
     | codomain
     | image
     | ln
     | log
     | moment
     | lambda
     | compose
     | quotient
     | divide
     | minus
     | power
     | rem
     | root
     | factorial
     | minus
     | root
     | abs
     | conjugate
     | arg
     | real
     | imaginary
     | floor
     | ceiling
     | exp
     | max
     | min
     | plus
     | times
     | gcd
     | lcm
     | and
     | or
     | xor
     | not
     | implies
     | equivalent
     | forall
     | exists
     | eq
     | gt
     | lt
     | geq
     | leq
     | neq
     | approx
     | factorof
     | tendsto
     | int
     | diff
     | partialdiff
     | divergence
     | grad
     | curl
     | laplacian
     | set
     | \list
     | union
     | intersect
     | cartesianproduct
     | in
     | notin
     | notsubset
     | notprsubset
     | setdiff
     | subset
     | prsubset
     | card
     | sum
     | product
     | limit
     | sin
     | cos
     | tan
     | sec
     | csc
     | cot
     | sinh
     | cosh
     | tanh
     | sech
     | csch
     | coth
     | arcsin
     | arccos
     | arctan
     | arccosh
     | arccot
     | arccoth
     | arccsc
     | arccsch
     | arcsec
     | arcsech
     | arcsinh
     | arctanh
     | mean
     | sdev
     | variance
     | median
     | mode
     | vector
     | matrix
     | matrixrow
     | determinant
     | transpose
     | selector
     | vectorproduct
     | scalarproduct
     | outerproduct
     | integers
     | reals
     | rationals
     | naturalnumbers
     | complexes
     | primes
     | emptyset
     | exponentiale
     | imaginaryi
     | notanumber
     | true
     | false
     | pi
     | eulergamma
     | infinity)*
  }
determinant =
  element m:determinant {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
transpose =
  element m:transpose {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
selector =
  element m:selector {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
vectorproduct =
  element m:vectorproduct {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
scalarproduct =
  element m:scalarproduct {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
outerproduct =
  element m:outerproduct {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
integers =
  element m:integers {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
reals =
  element m:reals {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
rationals =
  element m:rationals {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
naturalnumbers =
  element m:naturalnumbers {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
complexes =
  element m:complexes {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
primes =
  element m:primes {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
emptyset =
  element m:emptyset {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
exponentiale =
  element m:exponentiale {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
imaginaryi =
  element m:imaginaryi {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
notanumber =
  element m:notanumber {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
true =
  element m:true {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
false =
  element m:false {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
pi =
  element m:pi {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
eulergamma =
  element m:eulergamma {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
infinity =
  element m:infinity {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?
  }
mpadded-length =
  xsd:string {
    pattern =
      "\s*([\+\-]?[0-9]*(\.[0-9]*)?\s*((%?\s*(height|depth|width)?)|e[mx]|in|cm|mm|p[xtc]|((negative)?((very){0,2}thi(n|ck)|medium)mathspace)))\s*"
  }
unsigned-integer = xsd:unsignedLong
integer = xsd:integer
number = xsd:decimal
character = xsd:string { pattern = "\s*\S\s*" }
color =
  xsd:string {
    pattern =
      "\s*((#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?)|[aA][qQ][uU][aA]|[bB][lL][aA][cC][kK]|[bB][lL][uU][eE]|[fF][uU][cC][hH][sS][iI][aA]|[gG][rR][aA][yY]|[gG][rR][eE][eE][nN]|[lL][iI][mM][eE]|[mM][aA][rR][oO][oO][nN]|[nN][aA][vV][yY]|[oO][lL][iI][vV][eE]|[pP][uU][rR][pP][lL][eE]|[rR][eE][dD]|[sS][iI][lL][vV][eE][rR]|[tT][eE][aA][lL]|[wW][hH][iI][tT][eE]|[yY][eE][lL][lL][oO][wW])\s*"
  }
group-alignment-list-list =
  xsd:string {
    pattern =
      "(\s*\{\s*(left|center|right|decimalpoint)(\s+(left|center|right|decimalpoint))*\})*\s*"
  }
positive-integer = xsd:positiveInteger
mi =
  element m:mi {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    TokenAtt.mathvariant?,
    TokenAtt.mathsize?,
    TokenAtt.dir?,
    (mglyph | malignmark | text)*
  }
mn =
  element m:mn {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    TokenAtt.mathvariant?,
    TokenAtt.mathsize?,
    TokenAtt.dir?,
    (mglyph | malignmark | text)*
  }
mo =
  element m:mo {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    TokenAtt.mathvariant?,
    TokenAtt.mathsize?,
    TokenAtt.dir?,
    mo.attributes.form?,
    mo.attributes.fence?,
    mo.attributes.separator?,
    mo.attributes.lspace?,
    mo.attributes.rspace?,
    mo.attributes.stretchy?,
    mo.attributes.symmetric?,
    mo.attributes.maxsize?,
    mo.attributes.minsize?,
    mo.attributes.largeop?,
    mo.attributes.movablelimits?,
    mo.attributes.accent?,
    mo.attributes.linebreak?,
    mo.attributes.lineleading?,
    mo.attributes.linebreakstyle?,
    mo.attributes.linebreakmultchar?,
    mo.attributes.indentalign?,
    mo.attributes.indentshift?,
    mo.attributes.indenttarget?,
    mo.attributes.indentalignfirst?,
    mo.attributes.indentshiftfirst?,
    mo.attributes.indentalignlast?,
    mo.attributes.indentshiftlast?,
    (mglyph | malignmark | text)*
  }
mo.attributes.form = attribute form { "prefix" | "infix" | "postfix" }
mo.attributes.fence = attribute fence { "true" | "false" }
mo.attributes.separator = attribute separator { "true" | "false" }
mo.attributes.lspace = attribute lspace { length }
mo.attributes.rspace = attribute rspace { length }
mo.attributes.stretchy = attribute stretchy { "true" | "false" }
mo.attributes.symmetric = attribute symmetric { "true" | "false" }
mo.attributes.maxsize = attribute maxsize { length | "infinity" }
mo.attributes.minsize = attribute minsize { length }
mo.attributes.largeop = attribute largeop { "true" | "false" }
mo.attributes.movablelimits =
  attribute movablelimits { "true" | "false" }
mo.attributes.accent = attribute accent { "true" | "false" }
mo.attributes.linebreak =
  attribute linebreak {
    "auto" | "newline" | "nobreak" | "goodbreak" | "badbreak"
  }
mo.attributes.lineleading = attribute lineleading { length }
mo.attributes.linebreakstyle =
  attribute linebreakstyle {
    "before" | "after" | "duplicate" | "infixlinebreakstyle"
  }
mo.attributes.linebreakmultchar = attribute linebreakmultchar { text }
mo.attributes.indentalign =
  attribute indentalign { "left" | "center" | "right" | "auto" | "id" }
mo.attributes.indentshift = attribute indentshift { length }
mo.attributes.indenttarget = attribute indenttarget { text }
mo.attributes.indentalignfirst =
  attribute indentalignfirst {
    "left" | "center" | "right" | "auto" | "id" | "indentalign"
  }
mo.attributes.indentshiftfirst =
  attribute indentshiftfirst { length | "indentshift" }
mo.attributes.indentalignlast =
  attribute indentalignlast {
    "left" | "center" | "right" | "auto" | "id" | "indentalign"
  }
mo.attributes.indentshiftlast =
  attribute indentshiftlast { length | "indentshift" }
mtext =
  element m:mtext {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    TokenAtt.mathvariant?,
    TokenAtt.mathsize?,
    TokenAtt.dir?,
    (mglyph | malignmark | text)*
  }
mspace =
  element m:mspace {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    TokenAtt.mathvariant?,
    TokenAtt.mathsize?,
    TokenAtt.dir?,
    mspace.attributes.width?,
    mspace.attributes.height?,
    mspace.attributes.depth?,
    mspace.attributes.linebreak?
  }
mspace.attributes.width = attribute width { length }
mspace.attributes.height = attribute height { length }
mspace.attributes.depth = attribute depth { length }
mspace.attributes.linebreak =
  attribute linebreak {
    "auto"
    | "newline"
    | "nobreak"
    | "goodbreak"
    | "badbreak"
    | "indentingnewline"
  }
ms =
  element m:ms {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    TokenAtt.mathvariant?,
    TokenAtt.mathsize?,
    TokenAtt.dir?,
    ms.attributes.lquote?,
    ms.attributes.rquote?,
    (mglyph | malignmark | text)*
  }
ms.attributes.lquote = attribute lquote { text }
ms.attributes.rquote = attribute rquote { text }
mglyph =
  element m:mglyph {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mglyph.attributes.src?,
    mglyph.attributes.width?,
    mglyph.attributes.height?,
    mglyph.attributes.valign?,
    mglyph.attributes.alt?
  }
mglyph.attributes.src = attribute src { xsd:anyURI }
mglyph.attributes.width = attribute width { length }
mglyph.attributes.height = attribute height { length }
mglyph.attributes.valign =
  attribute valign { length | "top" | "middle" | "bottom" }
mglyph.attributes.alt = attribute alt { text }
msline =
  element m:msline {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    msline.attributes.position?,
    msline.attributes.length?,
    msline.attributes.leftoverhang?,
    msline.attributes.rightoverhang?,
    msline.attributes.mslinethickness?
  }
msline.attributes.position = attribute position { integer }
msline.attributes.length = attribute length { unsigned-integer }
msline.attributes.leftoverhang = attribute leftoverhang { length }
msline.attributes.rightoverhang = attribute rightoverhang { length }
msline.attributes.mslinethickness =
  attribute mslinethickness { length | "thin" | "medium" | "thick" }
none =
  element m:none {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?
  }
mprescripts =
  element m:mprescripts {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?
  }
CommonPresAtt.mathcolor = attribute mathcolor { color }
CommonPresAtt.mathbackground =
  attribute mathbackground { color | "transparent" }
TokenAtt.mathvariant =
  attribute mathvariant {
    "normal"
    | "bold"
    | "italic"
    | "bold-italic"
    | "double-struck"
    | "bold-fraktur"
    | "script"
    | "bold-script"
    | "fraktur"
    | "sans-serif"
    | "bold-sans-serif"
    | "sans-serif-italic"
    | "sans-serif-bold-italic"
    | "monospace"
    | "initial"
    | "tailed"
    | "looped"
    | "stretched"
  }
TokenAtt.mathsize =
  attribute mathsize { "small" | "normal" | "big" | length }
TokenAtt.dir = attribute dir { "ltr" | "rtl" }
malignmark =
  element m:malignmark {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    malignmark.attributes.edge?
  }
malignmark.attributes.edge = attribute edge { "left" | "right" }
maligngroup =
  element m:maligngroup {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    maligngroup.attributes.groupalign?
  }
maligngroup.attributes.groupalign =
  attribute groupalign { "left" | "center" | "right" | "decimalpoint" }
mrow =
  element m:mrow {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mrow.attributes.dir?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)*
  }
mrow.attributes.dir = attribute dir { "ltr" | "rtl" }
mfrac =
  element m:mfrac {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mfrac.attributes.linethickness?,
    mfrac.attributes.numalign?,
    mfrac.attributes.denomalign?,
    mfrac.attributes.bevelled?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)
  }
mfrac.attributes.linethickness =
  attribute linethickness { length | "thin" | "medium" | "thick" }
mfrac.attributes.numalign =
  attribute numalign { "left" | "center" | "right" }
mfrac.attributes.denomalign =
  attribute denomalign { "left" | "center" | "right" }
mfrac.attributes.bevelled = attribute bevelled { "true" | "false" }
msqrt =
  element m:msqrt {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)*
  }
mroot =
  element m:mroot {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)
  }
mstyle =
  element m:mstyle {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mstyle.specificattributes.scriptlevel?,
    mstyle.specificattributes.displaystyle?,
    mstyle.specificattributes.scriptsizemultiplier?,
    mstyle.specificattributes.scriptminsize?,
    mstyle.specificattributes.infixlinebreakstyle?,
    mstyle.specificattributes.decimalpoint?,
    mstyle.generalattributes.accent?,
    mstyle.generalattributes.accentunder?,
    mstyle.generalattributes.align?,
    mstyle.generalattributes.alignmentscope?,
    mstyle.generalattributes.bevelled?,
    mstyle.generalattributes.charalign?,
    mstyle.generalattributes.charspacing?,
    mstyle.generalattributes.close?,
    mstyle.generalattributes.columnalign?,
    mstyle.generalattributes.columnlines?,
    mstyle.generalattributes.columnspacing?,
    mstyle.generalattributes.columnspan?,
    mstyle.generalattributes.columnwidth?,
    mstyle.generalattributes.crossout?,
    mstyle.generalattributes.denomalign?,
    mstyle.generalattributes.depth?,
    mstyle.generalattributes.dir?,
    mstyle.generalattributes.edge?,
    mstyle.generalattributes.equalcolumns?,
    mstyle.generalattributes.equalrows?,
    mstyle.generalattributes.fence?,
    mstyle.generalattributes.form?,
    mstyle.generalattributes.frame?,
    mstyle.generalattributes.framespacing?,
    mstyle.generalattributes.groupalign?,
    mstyle.generalattributes.height?,
    mstyle.generalattributes.indentalign?,
    mstyle.generalattributes.indentalignfirst?,
    mstyle.generalattributes.indentalignlast?,
    mstyle.generalattributes.indentshift?,
    mstyle.generalattributes.indentshiftfirst?,
    mstyle.generalattributes.indentshiftlast?,
    mstyle.generalattributes.indenttarget?,
    mstyle.generalattributes.largeop?,
    mstyle.generalattributes.leftoverhang?,
    mstyle.generalattributes.length?,
    mstyle.generalattributes.linebreak?,
    mstyle.generalattributes.linebreakmultchar?,
    mstyle.generalattributes.linebreakstyle?,
    mstyle.generalattributes.lineleading?,
    mstyle.generalattributes.linethickness?,
    mstyle.generalattributes.location?,
    mstyle.generalattributes.longdivstyle?,
    mstyle.generalattributes.lquote?,
    mstyle.generalattributes.lspace?,
    mstyle.generalattributes.mathsize?,
    mstyle.generalattributes.mathvariant?,
    mstyle.generalattributes.maxsize?,
    mstyle.generalattributes.minlabelspacing?,
    mstyle.generalattributes.minsize?,
    mstyle.generalattributes.movablelimits?,
    mstyle.generalattributes.mslinethickness?,
    mstyle.generalattributes.notation?,
    mstyle.generalattributes.numalign?,
    mstyle.generalattributes.open?,
    mstyle.generalattributes.position?,
    mstyle.generalattributes.rightoverhang?,
    mstyle.generalattributes.rowalign?,
    mstyle.generalattributes.rowlines?,
    mstyle.generalattributes.rowspacing?,
    mstyle.generalattributes.rowspan?,
    mstyle.generalattributes.rquote?,
    mstyle.generalattributes.rspace?,
    mstyle.generalattributes.selection?,
    mstyle.generalattributes.separator?,
    mstyle.generalattributes.separators?,
    mstyle.generalattributes.shift?,
    mstyle.generalattributes.side?,
    mstyle.generalattributes.stackalign?,
    mstyle.generalattributes.stretchy?,
    mstyle.generalattributes.subscriptshift?,
    mstyle.generalattributes.superscriptshift?,
    mstyle.generalattributes.symmetric?,
    mstyle.generalattributes.valign?,
    mstyle.generalattributes.width?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)*
  }
mstyle.specificattributes.scriptlevel =
  attribute scriptlevel { integer }
mstyle.specificattributes.displaystyle =
  attribute displaystyle { "true" | "false" }
mstyle.specificattributes.scriptsizemultiplier =
  attribute scriptsizemultiplier { number }
mstyle.specificattributes.scriptminsize =
  attribute scriptminsize { length }
mstyle.specificattributes.infixlinebreakstyle =
  attribute infixlinebreakstyle { "before" | "after" | "duplicate" }
mstyle.specificattributes.decimalpoint =
  attribute decimalpoint { character }
mstyle.generalattributes.accent = attribute accent { "true" | "false" }
mstyle.generalattributes.accentunder =
  attribute accentunder { "true" | "false" }
mstyle.generalattributes.align =
  attribute align { "left" | "right" | "center" }
mstyle.generalattributes.alignmentscope =
  attribute alignmentscope {
    list { ("true" | "false")+ }
  }
mstyle.generalattributes.bevelled =
  attribute bevelled { "true" | "false" }
mstyle.generalattributes.charalign =
  attribute charalign { "left" | "center" | "right" }
mstyle.generalattributes.charspacing =
  attribute charspacing { length | "loose" | "medium" | "tight" }
mstyle.generalattributes.close = attribute close { text }
mstyle.generalattributes.columnalign =
  attribute columnalign {
    list { ("left" | "center" | "right")+ }
  }
mstyle.generalattributes.columnlines =
  attribute columnlines {
    list { ("none" | "solid" | "dashed")+ }
  }
mstyle.generalattributes.columnspacing =
  attribute columnspacing {
    list { length+ }
  }
mstyle.generalattributes.columnspan =
  attribute columnspan { positive-integer }
mstyle.generalattributes.columnwidth =
  attribute columnwidth {
    list { ("auto" | length | "fit")+ }
  }
mstyle.generalattributes.crossout =
  attribute crossout {
    list {
      ("none"
       | "updiagonalstrike"
       | "downdiagonalstrike"
       | "verticalstrike"
       | "horizontalstrike")*
    }
  }
mstyle.generalattributes.denomalign =
  attribute denomalign { "left" | "center" | "right" }
mstyle.generalattributes.depth = attribute depth { length }
mstyle.generalattributes.dir = attribute dir { "ltr" | "rtl" }
mstyle.generalattributes.edge = attribute edge { "left" | "right" }
mstyle.generalattributes.equalcolumns =
  attribute equalcolumns { "true" | "false" }
mstyle.generalattributes.equalrows =
  attribute equalrows { "true" | "false" }
mstyle.generalattributes.fence = attribute fence { "true" | "false" }
mstyle.generalattributes.form =
  attribute form { "prefix" | "infix" | "postfix" }
mstyle.generalattributes.frame =
  attribute frame { "none" | "solid" | "dashed" }
mstyle.generalattributes.framespacing =
  attribute framespacing {
    list { length, length }
  }
mstyle.generalattributes.groupalign =
  attribute groupalign { group-alignment-list-list }
mstyle.generalattributes.height = attribute height { length }
mstyle.generalattributes.indentalign =
  attribute indentalign { "left" | "center" | "right" | "auto" | "id" }
mstyle.generalattributes.indentalignfirst =
  attribute indentalignfirst {
    "left" | "center" | "right" | "auto" | "id" | "indentalign"
  }
mstyle.generalattributes.indentalignlast =
  attribute indentalignlast {
    "left" | "center" | "right" | "auto" | "id" | "indentalign"
  }
mstyle.generalattributes.indentshift = attribute indentshift { length }
mstyle.generalattributes.indentshiftfirst =
  attribute indentshiftfirst { length | "indentshift" }
mstyle.generalattributes.indentshiftlast =
  attribute indentshiftlast { length | "indentshift" }
mstyle.generalattributes.indenttarget = attribute indenttarget { text }
mstyle.generalattributes.largeop =
  attribute largeop { "true" | "false" }
mstyle.generalattributes.leftoverhang =
  attribute leftoverhang { length }
mstyle.generalattributes.length = attribute length { unsigned-integer }
mstyle.generalattributes.linebreak =
  attribute linebreak {
    "auto" | "newline" | "nobreak" | "goodbreak" | "badbreak"
  }
mstyle.generalattributes.linebreakmultchar =
  attribute linebreakmultchar { text }
mstyle.generalattributes.linebreakstyle =
  attribute linebreakstyle {
    "before" | "after" | "duplicate" | "infixlinebreakstyle"
  }
mstyle.generalattributes.lineleading = attribute lineleading { length }
mstyle.generalattributes.linethickness =
  attribute linethickness { length | "thin" | "medium" | "thick" }
mstyle.generalattributes.location =
  attribute location {
    "w" | "nw" | "n" | "ne" | "e" | "se" | "s" | "sw"
  }
mstyle.generalattributes.longdivstyle =
  attribute longdivstyle {
    "lefttop"
    | "stackedrightright"
    | "mediumstackedrightright"
    | "shortstackedrightright"
    | "righttop"
    | "left/\right"
    | "left)(right"
    | ":right=right"
    | "stackedleftleft"
    | "stackedleftlinetop"
  }
mstyle.generalattributes.lquote = attribute lquote { text }
mstyle.generalattributes.lspace = attribute lspace { length }
mstyle.generalattributes.mathsize =
  attribute mathsize { "small" | "normal" | "big" | length }
mstyle.generalattributes.mathvariant =
  attribute mathvariant {
    "normal"
    | "bold"
    | "italic"
    | "bold-italic"
    | "double-struck"
    | "bold-fraktur"
    | "script"
    | "bold-script"
    | "fraktur"
    | "sans-serif"
    | "bold-sans-serif"
    | "sans-serif-italic"
    | "sans-serif-bold-italic"
    | "monospace"
    | "initial"
    | "tailed"
    | "looped"
    | "stretched"
  }
mstyle.generalattributes.maxsize =
  attribute maxsize { length | "infinity" }
mstyle.generalattributes.minlabelspacing =
  attribute minlabelspacing { length }
mstyle.generalattributes.minsize = attribute minsize { length }
mstyle.generalattributes.movablelimits =
  attribute movablelimits { "true" | "false" }
mstyle.generalattributes.mslinethickness =
  attribute mslinethickness { length | "thin" | "medium" | "thick" }
mstyle.generalattributes.notation = attribute notation { text }
mstyle.generalattributes.numalign =
  attribute numalign { "left" | "center" | "right" }
mstyle.generalattributes.open = attribute open { text }
mstyle.generalattributes.position = attribute position { integer }
mstyle.generalattributes.rightoverhang =
  attribute rightoverhang { length }
mstyle.generalattributes.rowalign =
  attribute rowalign {
    list { ("top" | "bottom" | "center" | "baseline" | "axis")+ }
  }
mstyle.generalattributes.rowlines =
  attribute rowlines {
    list { ("none" | "solid" | "dashed")+ }
  }
mstyle.generalattributes.rowspacing =
  attribute rowspacing {
    list { length+ }
  }
mstyle.generalattributes.rowspan =
  attribute rowspan { positive-integer }
mstyle.generalattributes.rquote = attribute rquote { text }
mstyle.generalattributes.rspace = attribute rspace { length }
mstyle.generalattributes.selection =
  attribute selection { positive-integer }
mstyle.generalattributes.separator =
  attribute separator { "true" | "false" }
mstyle.generalattributes.separators = attribute separators { text }
mstyle.generalattributes.shift = attribute shift { integer }
mstyle.generalattributes.side =
  attribute side { "left" | "right" | "leftoverlap" | "rightoverlap" }
mstyle.generalattributes.stackalign =
  attribute stackalign { "left" | "center" | "right" | "decimalpoint" }
mstyle.generalattributes.stretchy =
  attribute stretchy { "true" | "false" }
mstyle.generalattributes.subscriptshift =
  attribute subscriptshift { length }
mstyle.generalattributes.superscriptshift =
  attribute superscriptshift { length }
mstyle.generalattributes.symmetric =
  attribute symmetric { "true" | "false" }
mstyle.generalattributes.valign =
  attribute valign { length | "top" | "middle" | "bottom" }
mstyle.generalattributes.width = attribute width { length }
merror =
  element m:merror {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)*
  }
mpadded =
  element m:mpadded {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mpadded.attributes.height?,
    mpadded.attributes.depth?,
    mpadded.attributes.width?,
    mpadded.attributes.lspace?,
    mpadded.attributes.voffset?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)*
  }
mpadded.attributes.height = attribute height { mpadded-length }
mpadded.attributes.depth = attribute depth { mpadded-length }
mpadded.attributes.width = attribute width { mpadded-length }
mpadded.attributes.lspace = attribute lspace { mpadded-length }
mpadded.attributes.voffset = attribute voffset { mpadded-length }
mphantom =
  element m:mphantom {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)*
  }
mfenced =
  element m:mfenced {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mfenced.attributes.open?,
    mfenced.attributes.close?,
    mfenced.attributes.separators?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)*
  }
mfenced.attributes.open = attribute open { text }
mfenced.attributes.close = attribute close { text }
mfenced.attributes.separators = attribute separators { text }
menclose =
  element m:menclose {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    menclose.attributes.notation?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)*
  }
menclose.attributes.notation = attribute notation { text }
msub =
  element m:msub {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    msub.attributes.subscriptshift?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)
  }
msub.attributes.subscriptshift = attribute subscriptshift { length }
msup =
  element m:msup {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    msup.attributes.superscriptshift?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)
  }
msup.attributes.superscriptshift = attribute superscriptshift { length }
msubsup =
  element m:msubsup {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    msubsup.attributes.subscriptshift?,
    msubsup.attributes.superscriptshift?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)
  }
msubsup.attributes.subscriptshift = attribute subscriptshift { length }
msubsup.attributes.superscriptshift =
  attribute superscriptshift { length }
munder =
  element m:munder {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    munder.attributes.accentunder?,
    munder.attributes.align?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)
  }
munder.attributes.accentunder =
  attribute accentunder { "true" | "false" }
munder.attributes.align =
  attribute align { "left" | "right" | "center" }
mover =
  element m:mover {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mover.attributes.accent?,
    mover.attributes.align?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)
  }
mover.attributes.accent = attribute accent { "true" | "false" }
mover.attributes.align = attribute align { "left" | "right" | "center" }
munderover =
  element m:munderover {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    munderover.attributes.accent?,
    munderover.attributes.accentunder?,
    munderover.attributes.align?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)
  }
munderover.attributes.accent = attribute accent { "true" | "false" }
munderover.attributes.accentunder =
  attribute accentunder { "true" | "false" }
munderover.attributes.align =
  attribute align { "left" | "right" | "center" }
mmultiscripts =
  element m:mmultiscripts {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    msubsup.attributes.subscriptshift?,
    msubsup.attributes.superscriptshift?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    ((mi
      | mn
      | mo
      | mtext
      | mspace
      | ms
      | maligngroup
      | malignmark
      | mrow
      | mfrac
      | msqrt
      | mroot
      | mstyle
      | merror
      | mpadded
      | mphantom
      | mfenced
      | menclose
      | msub
      | msup
      | msubsup
      | munder
      | mover
      | munderover
      | mmultiscripts
      | mtable
      | mstack
      | mlongdiv
      | maction
      | semantics
      | none),
     (mi
      | mn
      | mo
      | mtext
      | mspace
      | ms
      | maligngroup
      | malignmark
      | mrow
      | mfrac
      | msqrt
      | mroot
      | mstyle
      | merror
      | mpadded
      | mphantom
      | mfenced
      | menclose
      | msub
      | msup
      | msubsup
      | munder
      | mover
      | munderover
      | mmultiscripts
      | mtable
      | mstack
      | mlongdiv
      | maction
      | semantics
      | none))*,
    (mprescripts,
     ((mi
       | mn
       | mo
       | mtext
       | mspace
       | ms
       | maligngroup
       | malignmark
       | mrow
       | mfrac
       | msqrt
       | mroot
       | mstyle
       | merror
       | mpadded
       | mphantom
       | mfenced
       | menclose
       | msub
       | msup
       | msubsup
       | munder
       | mover
       | munderover
       | mmultiscripts
       | mtable
       | mstack
       | mlongdiv
       | maction
       | semantics
       | none),
      (mi
       | mn
       | mo
       | mtext
       | mspace
       | ms
       | maligngroup
       | malignmark
       | mrow
       | mfrac
       | msqrt
       | mroot
       | mstyle
       | merror
       | mpadded
       | mphantom
       | mfenced
       | menclose
       | msub
       | msup
       | msubsup
       | munder
       | mover
       | munderover
       | mmultiscripts
       | mtable
       | mstack
       | mlongdiv
       | maction
       | semantics
       | none))*)?
  }
mtable =
  element m:mtable {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mtable.attributes.align?,
    mtable.attributes.rowalign?,
    mtable.attributes.columnalign?,
    mtable.attributes.groupalign?,
    mtable.attributes.alignmentscope?,
    mtable.attributes.columnwidth?,
    mtable.attributes.width?,
    mtable.attributes.rowspacing?,
    mtable.attributes.columnspacing?,
    mtable.attributes.rowlines?,
    mtable.attributes.columnlines?,
    mtable.attributes.frame?,
    mtable.attributes.framespacing?,
    mtable.attributes.equalrows?,
    mtable.attributes.equalcolumns?,
    mtable.attributes.displaystyle?,
    mtable.attributes.side?,
    mtable.attributes.minlabelspacing?,
    (mtr | mlabeledtr)*
  }
mtable.attributes.align =
  attribute align {
    xsd:string {
      pattern = "\s*(top|bottom|center|baseline|axis)\s*[0-9]*"
    }
  }
mtable.attributes.rowalign =
  attribute rowalign {
    list { ("top" | "bottom" | "center" | "baseline" | "axis")+ }
  }
mtable.attributes.columnalign =
  attribute columnalign {
    list { ("left" | "center" | "right")+ }
  }
mtable.attributes.groupalign =
  attribute groupalign { group-alignment-list-list }
mtable.attributes.alignmentscope =
  attribute alignmentscope {
    list { ("true" | "false")+ }
  }
mtable.attributes.columnwidth =
  attribute columnwidth {
    list { ("auto" | length | "fit")+ }
  }
mtable.attributes.width = attribute width { "auto" | length }
mtable.attributes.rowspacing =
  attribute rowspacing {
    list { length+ }
  }
mtable.attributes.columnspacing =
  attribute columnspacing {
    list { length+ }
  }
mtable.attributes.rowlines =
  attribute rowlines {
    list { ("none" | "solid" | "dashed")+ }
  }
mtable.attributes.columnlines =
  attribute columnlines {
    list { ("none" | "solid" | "dashed")+ }
  }
mtable.attributes.frame =
  attribute frame { "none" | "solid" | "dashed" }
mtable.attributes.framespacing =
  attribute framespacing {
    list { length, length }
  }
mtable.attributes.equalrows = attribute equalrows { "true" | "false" }
mtable.attributes.equalcolumns =
  attribute equalcolumns { "true" | "false" }
mtable.attributes.displaystyle =
  attribute displaystyle { "true" | "false" }
mtable.attributes.side =
  attribute side { "left" | "right" | "leftoverlap" | "rightoverlap" }
mtable.attributes.minlabelspacing = attribute minlabelspacing { length }
mlabeledtr =
  element m:mlabeledtr {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mtr.attributes.rowalign?,
    mtr.attributes.columnalign?,
    mtr.attributes.groupalign?,
    mtd+
  }
mtr =
  element m:mtr {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mtr.attributes.rowalign?,
    mtr.attributes.columnalign?,
    mtr.attributes.groupalign?,
    mtd*
  }
mtr.attributes.rowalign =
  attribute rowalign {
    "top" | "bottom" | "center" | "baseline" | "axis"
  }
mtr.attributes.columnalign =
  attribute columnalign {
    list { ("left" | "center" | "right")+ }
  }
mtr.attributes.groupalign =
  attribute groupalign { group-alignment-list-list }
mtd =
  element m:mtd {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mtd.attributes.rowspan?,
    mtd.attributes.columnspan?,
    mtd.attributes.rowalign?,
    mtd.attributes.columnalign?,
    mtd.attributes.groupalign?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)*
  }
mtd.attributes.rowspan = attribute rowspan { positive-integer }
mtd.attributes.columnspan = attribute columnspan { positive-integer }
mtd.attributes.rowalign =
  attribute rowalign {
    "top" | "bottom" | "center" | "baseline" | "axis"
  }
mtd.attributes.columnalign =
  attribute columnalign { "left" | "center" | "right" }
mtd.attributes.groupalign =
  attribute groupalign {
    list { ("left" | "center" | "right" | "decimalpoint")+ }
  }
mstack =
  element m:mstack {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mstack.attributes.align?,
    mstack.attributes.stackalign?,
    mstack.attributes.charalign?,
    mstack.attributes.charspacing?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics
     | mscarries
     | msline
     | msrow
     | msgroup)*
  }
mstack.attributes.align =
  attribute align {
    xsd:string {
      pattern = "\s*(top|bottom|center|baseline|axis)\s*[0-9]*"
    }
  }
mstack.attributes.stackalign =
  attribute stackalign { "left" | "center" | "right" | "decimalpoint" }
mstack.attributes.charalign =
  attribute charalign { "left" | "center" | "right" }
mstack.attributes.charspacing =
  attribute charspacing { length | "loose" | "medium" | "tight" }
mlongdiv =
  element m:mlongdiv {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    msgroup.attributes.position?,
    msgroup.attributes.shift?,
    mlongdiv.attributes.longdivstyle?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics
     | mscarries
     | msline
     | msrow
     | msgroup),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics
     | mscarries
     | msline
     | msrow
     | msgroup),
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics
     | mscarries
     | msline
     | msrow
     | msgroup)+
  }
mlongdiv.attributes.longdivstyle =
  attribute longdivstyle {
    "lefttop"
    | "stackedrightright"
    | "mediumstackedrightright"
    | "shortstackedrightright"
    | "righttop"
    | "left/\right"
    | "left)(right"
    | ":right=right"
    | "stackedleftleft"
    | "stackedleftlinetop"
  }
msgroup =
  element m:msgroup {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    msgroup.attributes.position?,
    msgroup.attributes.shift?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics
     | mscarries
     | msline
     | msrow
     | msgroup)*
  }
msgroup.attributes.position = attribute position { integer }
msgroup.attributes.shift = attribute shift { integer }
msrow =
  element m:msrow {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    msrow.attributes.position?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics
     | none)*
  }
msrow.attributes.position = attribute position { integer }
mscarries =
  element m:mscarries {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mscarries.attributes.position?,
    mscarries.attributes.location?,
    mscarries.attributes.crossout?,
    mscarries.attributes.scriptsizemultiplier?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics
     | none
     | mscarry)*
  }
mscarries.attributes.position = attribute position { integer }
mscarries.attributes.location =
  attribute location {
    "w" | "nw" | "n" | "ne" | "e" | "se" | "s" | "sw"
  }
mscarries.attributes.crossout =
  attribute crossout {
    list {
      ("none"
       | "updiagonalstrike"
       | "downdiagonalstrike"
       | "verticalstrike"
       | "horizontalstrike")*
    }
  }
mscarries.attributes.scriptsizemultiplier =
  attribute scriptsizemultiplier { number }
mscarry =
  element m:mscarry {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mscarry.attributes.location?,
    mscarry.attributes.crossout?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics
     | none)*
  }
mscarry.attributes.location =
  attribute location {
    "w" | "nw" | "n" | "ne" | "e" | "se" | "s" | "sw"
  }
mscarry.attributes.crossout =
  attribute crossout {
    list {
      ("none"
       | "updiagonalstrike"
       | "downdiagonalstrike"
       | "verticalstrike"
       | "horizontalstrike")*
    }
  }
maction =
  element m:maction {
    xml.base.attrib?,
    xml.space.attrib?,
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    maction.attributes.actiontype?,
    maction.attributes.selection?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)+
  }
maction.attributes.actiontype = attribute actiontype { text }
maction.attributes.selection = attribute selection { positive-integer }
math =
  element m:math {
    CommonPresAtt.mathcolor?,
    CommonPresAtt.mathbackground?,
    mstyle.specificattributes.scriptlevel?,
    mstyle.specificattributes.displaystyle?,
    mstyle.specificattributes.scriptsizemultiplier?,
    mstyle.specificattributes.scriptminsize?,
    mstyle.specificattributes.infixlinebreakstyle?,
    mstyle.specificattributes.decimalpoint?,
    mstyle.generalattributes.accent?,
    mstyle.generalattributes.accentunder?,
    mstyle.generalattributes.align?,
    mstyle.generalattributes.alignmentscope?,
    mstyle.generalattributes.bevelled?,
    mstyle.generalattributes.charalign?,
    mstyle.generalattributes.charspacing?,
    mstyle.generalattributes.close?,
    mstyle.generalattributes.columnalign?,
    mstyle.generalattributes.columnlines?,
    mstyle.generalattributes.columnspacing?,
    mstyle.generalattributes.columnspan?,
    mstyle.generalattributes.columnwidth?,
    mstyle.generalattributes.crossout?,
    mstyle.generalattributes.denomalign?,
    mstyle.generalattributes.depth?,
    mstyle.generalattributes.dir?,
    mstyle.generalattributes.edge?,
    mstyle.generalattributes.equalcolumns?,
    mstyle.generalattributes.equalrows?,
    mstyle.generalattributes.fence?,
    mstyle.generalattributes.form?,
    mstyle.generalattributes.frame?,
    mstyle.generalattributes.framespacing?,
    mstyle.generalattributes.groupalign?,
    mstyle.generalattributes.height?,
    mstyle.generalattributes.indentalign?,
    mstyle.generalattributes.indentalignfirst?,
    mstyle.generalattributes.indentalignlast?,
    mstyle.generalattributes.indentshift?,
    mstyle.generalattributes.indentshiftfirst?,
    mstyle.generalattributes.indentshiftlast?,
    mstyle.generalattributes.indenttarget?,
    mstyle.generalattributes.largeop?,
    mstyle.generalattributes.leftoverhang?,
    mstyle.generalattributes.length?,
    mstyle.generalattributes.linebreak?,
    mstyle.generalattributes.linebreakmultchar?,
    mstyle.generalattributes.linebreakstyle?,
    mstyle.generalattributes.lineleading?,
    mstyle.generalattributes.linethickness?,
    mstyle.generalattributes.location?,
    mstyle.generalattributes.longdivstyle?,
    mstyle.generalattributes.lquote?,
    mstyle.generalattributes.lspace?,
    mstyle.generalattributes.mathsize?,
    mstyle.generalattributes.mathvariant?,
    mstyle.generalattributes.maxsize?,
    mstyle.generalattributes.minlabelspacing?,
    mstyle.generalattributes.minsize?,
    mstyle.generalattributes.movablelimits?,
    mstyle.generalattributes.mslinethickness?,
    mstyle.generalattributes.notation?,
    mstyle.generalattributes.numalign?,
    mstyle.generalattributes.open?,
    mstyle.generalattributes.position?,
    mstyle.generalattributes.rightoverhang?,
    mstyle.generalattributes.rowalign?,
    mstyle.generalattributes.rowlines?,
    mstyle.generalattributes.rowspacing?,
    mstyle.generalattributes.rowspan?,
    mstyle.generalattributes.rquote?,
    mstyle.generalattributes.rspace?,
    mstyle.generalattributes.selection?,
    mstyle.generalattributes.separator?,
    mstyle.generalattributes.separators?,
    mstyle.generalattributes.shift?,
    mstyle.generalattributes.side?,
    mstyle.generalattributes.stackalign?,
    mstyle.generalattributes.stretchy?,
    mstyle.generalattributes.subscriptshift?,
    mstyle.generalattributes.superscriptshift?,
    mstyle.generalattributes.symmetric?,
    mstyle.generalattributes.valign?,
    mstyle.generalattributes.width?,
    xml.base.attrib?,
    xml.space.attrib?,
    math.attributes.display?,
    math.attributes.maxwidth?,
    math.attributes.overflow?,
    math.attributes.altimg?,
    math.attributes.altimg-width?,
    math.attributes.altimg-height?,
    math.attributes.altimg-valign?,
    math.attributes.alttext?,
    math.attributes.cdgroup?,
    math.deprecatedattributes.mode?,
    math.deprecatedattributes.macros?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics)+
  }
math.deprecatedattributes.mode = attribute mode { xsd:string }
math.deprecatedattributes.macros = attribute macros { xsd:string }
name = attribute name { xsd:NCName }
cd = attribute cd { xsd:NCName }
src = attribute src { xsd:anyURI }?
annotation =
  element m:annotation {
    xml.base.attrib?,
    xml.space.attrib?,
    cd?,
    name?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    src?,
    text
  }
annotation-xml =
  element m:annotation-xml {
    xml.base.attrib?,
    xml.space.attrib?,
    cd?,
    name?,
    annotation-xml.specialized.attlist.definitionURL?,
    ((annotation-xml.specialized.choice.encoding,
      (src
       | (semantics-contexp
          | cn
          | ci
          | csymbol
          | apply
          | bind
          | share
          | cerror
          | cbytes
          | share
          | cerror
          | cbytes
          | cs
          | piecewise
          | empty
          | interval
          | inverse
          | ident
          | domain
          | codomain
          | image
          | ln
          | log
          | moment
          | lambda
          | compose
          | quotient
          | divide
          | minus
          | power
          | rem
          | root
          | factorial
          | minus
          | root
          | abs
          | conjugate
          | arg
          | real
          | imaginary
          | floor
          | ceiling
          | exp
          | max
          | min
          | plus
          | times
          | gcd
          | lcm
          | and
          | or
          | xor
          | not
          | implies
          | equivalent
          | forall
          | exists
          | eq
          | gt
          | lt
          | geq
          | leq
          | neq
          | approx
          | factorof
          | tendsto
          | int
          | diff
          | partialdiff
          | divergence
          | grad
          | curl
          | laplacian
          | set
          | \list
          | union
          | intersect
          | cartesianproduct
          | in
          | notin
          | notsubset
          | notprsubset
          | setdiff
          | subset
          | prsubset
          | card
          | sum
          | product
          | limit
          | sin
          | cos
          | tan
          | sec
          | csc
          | cot
          | sinh
          | cosh
          | tanh
          | sech
          | csch
          | coth
          | arcsin
          | arccos
          | arctan
          | arccosh
          | arccot
          | arccoth
          | arccsc
          | arccsch
          | arcsec
          | arcsech
          | arcsinh
          | arctanh
          | mean
          | sdev
          | variance
          | median
          | mode
          | vector
          | matrix
          | matrixrow
          | determinant
          | transpose
          | selector
          | vectorproduct
          | scalarproduct
          | outerproduct
          | integers
          | reals
          | rationals
          | naturalnumbers
          | complexes
          | primes
          | emptyset
          | exponentiale
          | imaginaryi
          | notanumber
          | true
          | false
          | pi
          | eulergamma
          | infinity)+))
     | (annotation-xml.specialized.choice.encoding_1,
        (src
         | (mi
            | mn
            | mo
            | mtext
            | mspace
            | ms
            | maligngroup
            | malignmark
            | mrow
            | mfrac
            | msqrt
            | mroot
            | mstyle
            | merror
            | mpadded
            | mphantom
            | mfenced
            | menclose
            | msub
            | msup
            | msubsup
            | munder
            | mover
            | munderover
            | mmultiscripts
            | mtable
            | mstack
            | mlongdiv
            | maction
            | semantics)+))
     | (annotation-xml.specialized.choice.encoding_2,
        ((z3998.hd
          | z3998.block
          | z3998.p
          | z3998.transition
          | z3998.list
          | z3998.table
          | z3998.code.block
          | z3998.quote.block
          | z3998.citation.block
          | z3998.object.block
          | z3998.address
          | z3998.note
          | z3998.annotation
          | z3998.aside
          | z3998.caption
          | z3998.verse
          | z3998.description
          | ssml.break
          | math
          | z3998.select.block
          | xforms.group
          | xforms.repeat
          | z3998.feature.description
          | z3998.pagebreak)+
         | (text
            | z3998.object.text
            | z3998.sub
            | z3998.sup
            | z3998.char
            | z3998.span.text
            | z3998.emph.text
            | ssml.break
            | ssml.phoneme.text
            | ssml.prosody.text
            | ssml.say-as.text
            | ssml.sub.text
            | ssml.token.text
            | its-ruby
            | z3998.span
            | z3998.ref
            | z3998.code.phrase
            | z3998.object.phrase
            | z3998.address.phrase
            | z3998.noteref
            | z3998.note.phrase
            | z3998.annoref
            | z3998.ln
            | z3998.s
            | z3998.w
            | z3998.w
            | z3998.expansion
            | z3998.abbr
            | z3998.emph
            | z3998.time
            | z3998.name
            | z3998.definition
            | z3998.term
            | z3998.d
            | z3998.num
            | z3998.rend.linebreak
            | z3998.quote.phrase
            | z3998.citation
            | z3998.annotation.phrase
            | ssml.break
            | ssml.phoneme
            | ssml.prosody
            | ssml.say-as
            | ssml.sub
            | ssml.token
            | math
            | z3998.select.phrase
            | xforms.input
            | xforms.textarea
            | xforms.secret
            | xforms.select1
            | xforms.select
            | xforms.range
            | z3998.pagebreak)+)
        >> sch:rule [
             context = "m:annotation-xml[@encoding='Z39.98-AI']"
             "\x{a}" ~
             "                        "
             sch:assert [
               test = "not(descendant::m:*)"
               "The annotation-xml element, when used with Z39.98-AI markup, must not contain any descendants in the MathML namespace. "
             ]
             "\x{a}" ~
             "                    "
           ]))
  }
DefEncAtt.encoding = attribute encoding { xsd:string }
DefEncAtt.definitionURL = attribute definitionURL { xsd:anyURI }
semantics =
  element m:semantics {
    xml.base.attrib?,
    xml.space.attrib?,
    DefEncAtt.encoding?,
    DefEncAtt.definitionURL?,
    cd?,
    name?,
    (mi
     | mn
     | mo
     | mtext
     | mspace
     | ms
     | maligngroup
     | malignmark
     | mrow
     | mfrac
     | msqrt
     | mroot
     | mstyle
     | merror
     | mpadded
     | mphantom
     | mfenced
     | menclose
     | msub
     | msup
     | msubsup
     | munder
     | mover
     | munderover
     | mmultiscripts
     | mtable
     | mstack
     | mlongdiv
     | maction
     | semantics),
    (annotation | annotation-xml)*
  }
length =
  xsd:string {
    pattern =
      "\s*((-?[0-9]*(\.[0-9]*)?(e[mx]|in|cm|mm|p[xtc]|%)?)|(negative)?((very){0,2}thi(n|ck)|medium)mathspace)\s*"
  }
annotation-xml.specialized.attlist.definitionURL =
  attribute definitionURL { xsd:anyURI }
annotation-xml.specialized.choice.encoding =
  attribute encoding {
    "application/mathml-content+xml" | "MathML-Content"
  }
annotation-xml.specialized.choice.encoding_1 =
  attribute encoding {
    "application/mathml-presentation+xml" | "MathML-Presentation"
  }
annotation-xml.specialized.choice.encoding_2 =
  attribute encoding { "Z39.98-AI" }
z3998.select.phrase =
  
  ## Container for content selection declarations in a Phrase context. 
  element sel:select {
    xml.id.attrib?,
    xml.base.attrib?,
    z3998.when.phrase+,
    z3998.otherwise.phrase
  }
z3998.select.block =
  
  ## Container for content selection declarations in a Block context. 
  element sel:select {
    xml.id.attrib?,
    xml.base.attrib?,
    z3998.when.block+,
    z3998.otherwise.block
  }
z3998.when.phrase =
  
  ## Container for a content fragment, associated with a selection condition. 
  element sel:when {
    xml.id.attrib?,
    z3998.expr.attrib,
    (text
     | z3998.object.text
     | z3998.sub
     | z3998.sup
     | z3998.char
     | z3998.span.text
     | z3998.emph.text
     | ssml.break
     | ssml.phoneme.text
     | ssml.prosody.text
     | ssml.say-as.text
     | ssml.sub.text
     | ssml.token.text
     | its-ruby
     | z3998.span
     | z3998.ref
     | z3998.code.phrase
     | z3998.object.phrase
     | z3998.address.phrase
     | z3998.noteref
     | z3998.note.phrase
     | z3998.annoref
     | z3998.ln
     | z3998.s
     | z3998.w
     | z3998.w
     | z3998.expansion
     | z3998.abbr
     | z3998.emph
     | z3998.time
     | z3998.name
     | z3998.definition
     | z3998.term
     | z3998.d
     | z3998.num
     | z3998.rend.linebreak
     | z3998.quote.phrase
     | z3998.citation
     | z3998.annotation.phrase
     | ssml.break
     | ssml.phoneme
     | ssml.prosody
     | ssml.say-as
     | ssml.sub
     | ssml.token
     | math
     | z3998.select.phrase
     | xforms.input
     | xforms.textarea
     | xforms.secret
     | xforms.select1
     | xforms.select
     | xforms.range
     | z3998.pagebreak)+
  }
z3998.when.block =
  
  ## Container for a content fragment, associated with a selection condition. 
  element sel:when {
    xml.id.attrib?,
    z3998.expr.attrib,
    (z3998.hd
     | z3998.block
     | z3998.p
     | z3998.transition
     | z3998.list
     | z3998.table
     | z3998.code.block
     | z3998.quote.block
     | z3998.citation.block
     | z3998.object.block
     | z3998.address
     | z3998.note
     | z3998.annotation
     | z3998.aside
     | z3998.caption
     | z3998.verse
     | z3998.description
     | ssml.break
     | math
     | z3998.select.block
     | xforms.group
     | xforms.repeat
     | z3998.feature.description
     | z3998.pagebreak)+
  }
z3998.otherwise.phrase =
  
  ## Container for a content fragment to be selected if none of the preceding 
  ##  when.phrase  conditions evaluated to true. 
  element sel:otherwise {
    xml.id.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "sel:otherwise"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::sel:select)"
           "The sel:otherwise element must not have sel:select descendants. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.otherwise.block =
  
  ## Container for a content fragment to be selected if none of the preceding 
  ##  when.block  conditions evaluated to true. 
  element sel:otherwise {
    xml.id.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+)
    >> sch:rule [
         context = "sel:otherwise"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "not(descendant::sel:select)"
           "The sel:otherwise element must not have sel:select descendants. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.expr.attrib =
  
  ## The expr attribute contains a conditional expression. Refer to the 
  ##  Content Selection Feature  for information on syntax and function set association. 
  attribute expr { z3998.select.ConditionalExpression.datatype }

## A conditional expression, as defined in 
##  Conditional Expression  
z3998.select.ConditionalExpression.datatype = string
z3998.select.selid.attrib =
  
  ## The selid attribute provides a mechanism for including ID values on elements that are repeated in more than one select condition. The selid allows a single NCNAME as its value. When processing a select, all selid attributes in the resulting output condition must be converted to xml:id attributes. 
  attribute sel:selid { NCName.datatype }
xforms.Single.Node.Binding.attrib.model = attribute model { xsd:IDREF }
xforms.Single.Node.Binding.attrib.ref =
  attribute ref { XPathExpression }
xforms.Single.Node.Binding.attrib.bind = attribute bind { xsd:IDREF }
xforms.Nodeset.Binding.attrib.model = attribute model { xsd:IDREF }
xforms.Nodeset.Binding.attrib.nodeset =
  attribute nodeset { XPathExpression }
xforms.Nodeset.Binding.attrib.bind = attribute bind { xsd:IDREF }
xforms.model =
  element xforms:model {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    xforms.model.attrib.functions?,
    xforms.model.attrib.schema?,
    xforms.model.attrib.version?,
    (xforms.instance* & xforms.submission* & xforms.bind*)
  }
xforms.model.attrib.functions =
  attribute functions {
    list { xsd:QName+ }
  }
xforms.model.attrib.schema =
  attribute schema {
    list { xsd:anyURI+ }
  }
xforms.model.attrib.version =
  attribute version {
    list {
      xsd:string { pattern = "[1-9]\d*\.\d+" }
    }
  }
xforms.instance =
  element xforms:instance {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    xforms.instance.attrib.src?,
    xforms.instance.attrib.resource?,
    z3998.forms.instance.content.temp
  }
xforms.instance.attrib.src = attribute src { URI.datatype }
xforms.instance.attrib.resource = attribute resource { URI.datatype }
xforms.submission =
  element xforms:submission {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.submission.model.method_1 | xforms.submission.model.method),
    (xforms.submission.model.action
     | xforms.submission.model.resource_1
     | xforms.submission.model.resource),
    xforms.submission.model.header*,
    xforms.submission.model.bind?,
    xforms.submission.model.ref?,
    xforms.submission.model.includenamespaceprefixes?,
    xforms.submission.model.indent?,
    xforms.submission.model.encoding?,
    xforms.submission.model.mode?,
    xforms.submission.model.omit-xml-declaration?,
    xforms.submission.model.mediatype?,
    xforms.submission.model.standalone?,
    xforms.submission.model.cdata-section-elements?,
    xforms.submission.model.replace?,
    xforms.submission.model.instance?,
    xforms.submission.model.relevant?,
    xforms.submission.model.separator?,
    xforms.submission.model.serialization?,
    xforms.submission.model.validate?,
    xforms.submission.model.version?,
    xforms.submission.model.targetref?
  }
xforms.submission.model.method =
  element xforms:method { XPathExpression }
xforms.submission.model.resource.value =
  attribute value { XPathExpression }
xforms.submission.model.resource =
  element xforms:resource {
    xforms.submission.model.resource.value?, XPathExpression
  }
xforms.submission.model.header.name =
  element xforms:name { XPathExpression }
xforms.submission.model.header.value =
  element xforms:value { XPathExpression }
xforms.submission.model.header =
  element xforms:header {
    xforms.submission.model.header.name
    & xforms.submission.model.header.value
  }
xforms.submission.model.method_1 =
  attribute method {
    QNameButNotNCName
    | "post"
    | "put"
    | "get"
    | "delete"
    | "post"
    | "form-data-post"
    | "urlencoded-post"
  }
xforms.submission.model.action = attribute action { xsd:anyURI }
xforms.submission.model.resource_1 = attribute resource { xsd:anyURI }
xforms.submission.model.bind = attribute bind { xsd:IDREF }
xforms.submission.model.ref = attribute ref { XPathExpression }
xforms.submission.model.includenamespaceprefixes =
  attribute includenamespaceprefixes {
    list { xsd:NCName | "#default" }
  }
xforms.submission.model.indent = attribute indent { xsd:boolean }
xforms.submission.model.encoding = attribute encoding { text }
xforms.submission.model.mode =
  attribute mode { "asynchronous" | "synchronous" }
xforms.submission.model.omit-xml-declaration =
  attribute omit-xml-declaration { xsd:boolean }
xforms.submission.model.mediatype = attribute mediatype { text }
xforms.submission.model.standalone =
  attribute standalone { xsd:boolean }
xforms.submission.model.cdata-section-elements =
  attribute cdata-section-elements {
    list { xsd:QName+ }
  }
xforms.submission.model.replace =
  attribute replace { QNameButNotNCName | "all" | "instance" | "none" }
xforms.submission.model.instance = attribute instance { xsd:IDREF }
xforms.submission.model.relevant = attribute relevant { xsd:boolean }
xforms.submission.model.separator = attribute separator { ";" | "&" }
xforms.submission.model.serialization =
  attribute serialization {
    "application/xml"
    | "application/x-www-form-urlencoded"
    | "multipart/related"
    | "multipart/form-data"
    | "none"
  }
xforms.submission.model.validate = attribute validate { xsd:boolean }
xforms.submission.model.version = attribute version { xsd:NMTOKEN }
xforms.submission.model.targetref =
  attribute targetref { XPathExpression }
xforms.bind =
  element xforms:bind {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    xforms.bind.attrib.nodeset?,
    xforms.bind.attrib.calculate?,
    xforms.bind.attrib.type?,
    xforms.bind.attrib.required?,
    xforms.bind.attrib.constraint?,
    xforms.bind.attrib.relevant?,
    xforms.bind.attrib.readonly?,
    xforms.bind.attrib.p3ptype?,
    xforms.bind*
  }
xforms.bind.attrib.nodeset = attribute nodeset { XPathExpression }
xforms.bind.attrib.calculate = attribute calculate { XPathExpression }
xforms.bind.attrib.type = attribute type { xsd:QName }
xforms.bind.attrib.required = attribute required { XPathExpression }
xforms.bind.attrib.constraint = attribute constraint { XPathExpression }
xforms.bind.attrib.relevant = attribute relevant { XPathExpression }
xforms.bind.attrib.readonly = attribute readonly { XPathExpression }
xforms.bind.attrib.p3ptype = attribute p3ptype { text }
UI.xforms.Common.attrib &=
  attribute appearance {
    xsd:QName { pattern = "[^:]+:[^:]+" }
    | "minimal"
    | "compact"
    | "full"
  }?
xforms.label =
  element xforms:label {
    xml.id.attrib?
    & xml.space.attrib?
    & xml.base.attrib?
    & z3998.class.attrib?
    & xml.lang.attrib?
    & its.dir.attrib?
    & its.translate.attrib?
    & z3998.role.attrib?
    & (xforms.Linking.attrib.src
       | (xforms.Single.Node.Binding.attrib.model?,
          xforms.Single.Node.Binding.attrib.ref?,
          xforms.Single.Node.Binding.attrib.bind?)
       | (text
          | z3998.span
          | z3998.ref
          | z3998.code.phrase
          | z3998.object.phrase
          | z3998.address.phrase
          | z3998.noteref
          | z3998.note.phrase
          | z3998.annoref
          | z3998.ln
          | z3998.s
          | z3998.w
          | z3998.w
          | z3998.expansion
          | z3998.abbr
          | z3998.emph
          | z3998.time
          | z3998.name
          | z3998.definition
          | z3998.term
          | z3998.d
          | z3998.num
          | z3998.rend.linebreak
          | z3998.quote.phrase
          | z3998.citation
          | z3998.annotation.phrase
          | ssml.break
          | ssml.phoneme
          | ssml.prosody
          | ssml.say-as
          | ssml.sub
          | ssml.token
          | math
          | z3998.select.phrase
          | xforms.input
          | xforms.textarea
          | xforms.secret
          | xforms.select1
          | xforms.select
          | xforms.range)+)
  }
xforms.choices =
  element xforms:choices {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    xforms.label?,
    (xforms.choices | xforms.item | xforms.itemset)+
  }
xforms.value =
  element xforms:value {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.Single.Node.Binding.attrib.model?,
     xforms.Single.Node.Binding.attrib.ref?,
     xforms.Single.Node.Binding.attrib.bind?)?,
    text
  }
xforms.item =
  element xforms:item {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    xforms.label,
    xforms.value
  }
xforms.itemset =
  element xforms:itemset {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    xforms.Nodeset.Binding.attrib.model?,
    xforms.Nodeset.Binding.attrib.nodeset?,
    xforms.Nodeset.Binding.attrib.bind?,
    xforms.label,
    (xforms.value | xforms.copy)
  }
xforms.copy =
  element xforms:copy {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.Single.Node.Binding.attrib.model?,
     xforms.Single.Node.Binding.attrib.ref?,
     xforms.Single.Node.Binding.attrib.bind?)
  }
xforms.input =
  element xforms:input {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.Single.Node.Binding.attrib.model?,
     xforms.Single.Node.Binding.attrib.ref?,
     xforms.Single.Node.Binding.attrib.bind?),
    xforms.input.attrib.inputmode?,
    UI.xforms.Common.attrib,
    xforms.input.attrib.incremental?,
    xforms.label
  }
xforms.input.attrib.inputmode = attribute inputmode { text }
xforms.input.attrib.incremental = attribute incremental { xsd:boolean }
xforms.textarea =
  element xforms:textarea {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.Single.Node.Binding.attrib.model?,
     xforms.Single.Node.Binding.attrib.ref?,
     xforms.Single.Node.Binding.attrib.bind?),
    xforms.textarea.attrib.inputmode?,
    UI.xforms.Common.attrib,
    xforms.textarea.attrib.incremental?,
    xforms.label
  }
xforms.textarea.attrib.inputmode = attribute inputmode { text }
xforms.textarea.attrib.incremental =
  attribute incremental { xsd:boolean }
xforms.secret =
  element xforms:secret {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.Single.Node.Binding.attrib.model?,
     xforms.Single.Node.Binding.attrib.ref?,
     xforms.Single.Node.Binding.attrib.bind?),
    xforms.secret.attrib.inputmode?,
    UI.xforms.Common.attrib,
    xforms.secret.attrib.incremental?,
    xforms.label
  }
xforms.secret.attrib.inputmode = attribute inputmode { text }
xforms.secret.attrib.incremental = attribute incremental { xsd:boolean }
xforms.select1 =
  element xforms:select1 {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.Single.Node.Binding.attrib.model?,
     xforms.Single.Node.Binding.attrib.ref?,
     xforms.Single.Node.Binding.attrib.bind?),
    UI.xforms.Common.attrib,
    xforms.select1.attrib.selection?,
    xforms.select1.attrib.incremental?,
    xforms.label,
    (xforms.item | xforms.itemset | xforms.choices)+
  }
xforms.select1.attrib.selection =
  attribute selection { "open" | "closed" }
xforms.select1.attrib.incremental =
  attribute incremental { xsd:boolean }
xforms.select =
  element xforms:select {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.Single.Node.Binding.attrib.model?,
     xforms.Single.Node.Binding.attrib.ref?,
     xforms.Single.Node.Binding.attrib.bind?),
    UI.xforms.Common.attrib,
    xforms.select.attrib.selection?,
    xforms.select.attrib.incremental?,
    xforms.label,
    (xforms.item | xforms.itemset | xforms.choices)+
  }
xforms.select.attrib.selection =
  attribute selection { "open" | "closed" }
xforms.select.attrib.incremental = attribute incremental { xsd:boolean }
xforms.range =
  element xforms:range {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.Single.Node.Binding.attrib.model?,
     xforms.Single.Node.Binding.attrib.ref?,
     xforms.Single.Node.Binding.attrib.bind?),
    UI.xforms.Common.attrib,
    xforms.range.attrib.start?,
    xforms.range.attrib.end?,
    xforms.range.attrib.step?,
    xforms.range.attrib.incremental?,
    xforms.label
  }
xforms.range.attrib.start = attribute start { text }
xforms.range.attrib.end = attribute end { text }
xforms.range.attrib.step = attribute step { text }
xforms.range.attrib.incremental = attribute incremental { xsd:boolean }
xforms.repeat =
  element xforms:repeat {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    xforms.Nodeset.Binding.attrib.model?,
    xforms.Nodeset.Binding.attrib.nodeset?,
    xforms.Nodeset.Binding.attrib.bind?,
    UI.xforms.Common.attrib,
    xforms.repeat.attrib.startindex?,
    xforms.repeat.attrib.number?,
    (xforms.group
     | xforms.repeat
     | (text
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range)+)*
  }
xforms.repeat.attrib.startindex =
  attribute startindex { xsd:positiveInteger }
xforms.repeat.attrib.number =
  attribute number { xsd:nonNegativeInteger }
xforms.group =
  element xforms:group {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    z3998.role.attrib?,
    (xforms.Single.Node.Binding.attrib.model?,
     xforms.Single.Node.Binding.attrib.ref?,
     xforms.Single.Node.Binding.attrib.bind?)?,
    UI.xforms.Common.attrib,
    xforms.label?,
    (xforms.group
     | xforms.repeat
     | (text
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range)+)*
  }
QNameButNotNCName = xsd:QName { pattern = "[^:]+:[^:]+" }
XPathExpression = xsd:string
xforms.anyElement.null = attribute * { text }
xforms.anyElement =
  element * { (xforms.anyElement.null | text | xforms.anyElement)* }
xforms.anyXSDElement.null = attribute * { text }
xforms.anyXSDElement =
  element xs:* {
    (xforms.anyXSDElement.null | text | xforms.anyXSDElement)*
  }
z3998.forms.instance.content.temp.null = attribute i:* { text }
z3998.forms.instance.content.temp =
  element i:* {
    z3998.forms.instance.content.temp.null*,
    (z3998.forms.instance.content.temp | text)*
  }
z3998.rend.symbol.attrib =
  
  ## The rend:symbol attribute specifies the textual symbol used to represent a context break in the source document. As an alternative to rend:symbol, the 
  ##  src attribute  may be used to include an image symbol. Note that allowed media types in the src attribute are limited to the same set as the media types allowed on the object element. The rend:symbol and src attributes must not occur simultaneously on the same element. 
  attribute rend:symbol { text }
z3998.rend.list.ordered.prefix.attrib =
  
  ## The rend:prefix attribute specifies the symbol used as prefixes to the item children of an ordered list in the source document. The semantics of the allowed values of this attribute are defined by the 
  ##  CSS list-style-type property . The value specified in rend:prefix is inherited by any descendant lists, unless such descendant lists specify a rend:prefix attribute themselves. In terms of the 
  ##  CSS cascade , values provided here must be considered as of author origin. For more specialized symbols than the ones supported by the rend:prefix attribute on list, the 
  ##  rend:prefix attribute on item  can be used. 
  attribute rend:prefix {
    "none"
    | "decimal"
    | "decimal-leading-zero"
    | "lower-alpha"
    | "lower-greek"
    | "lower-latin"
    | "lower-roman"
    | "upper-alpha"
    | "upper-greek"
    | "upper-latin"
    | "upper-roman "
  }
z3998.rend.list.unordered.prefix.attrib =
  
  ## The rend:prefix attribute specifies the symbol used as prefixes to the item children of an unordered list in the source document. The semantics of the allowed values of this attribute are defined by the 
  ##  CSS list-style-type property . The value specified in rend:prefix is inherited by any descendant lists, unless such descendant lists specify a rend:prefix attribute themselves. In terms of the 
  ##  CSS cascade , values provided here must be considered as of author origin. For more specialized symbols than the ones supported by the rend:prefix attribute on list, the 
  ##  rend:prefix attribute on item  can be used. 
  attribute rend:prefix {
    "none"
    | "box"
    | "check"
    | "circle"
    | "diamond"
    | "disc"
    | "hyphen"
    | "square"
  }
z3998.rend.list.item.prefix.attrib =
  
  ## The rend:prefix attribute specifies the symbol used as a prefix to the content of the list item element. The occurrence of this attribute results in the prefix inheritance, as set by the prefix attribute on a list ancestor, ceases to be active, for this item, any following item siblings, and any child lists. To specify prefix symbols common to multiple list items, see 
  ##  rend.list.unordered.prefix  and 
  ##  rend.list.ordered.prefix . 
  attribute rend:prefix { NonEmptyString.datatype }
z3998.rend.prefix.attrib =
  
  ## The rend:prefix attribute specifies the characters or symbols that prefix an element. This variant is intended for use where the attribute and its value carry no special semantics or processing requirements, such as for values that prefix notes and annotations. 
  attribute rend:prefix { NonEmptyString.datatype }
z3998.rend.linebreak =
  
  ## The linebreak element represents a forced line ending. The 
  ##  ln  element should be used whenever the text content represents discrete lines. 
  element rend:linebreak {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (ssml.ph.ns.attrib, ssml.alphabet.ns.attrib)?
  }
z3998.feature.description =
  
  ## The description element is the root container element for a description. It consists of an optional container element for metadata information (the 
  ##  head ) and a required container for the different description types and alternate image renditions (the 
  ##  body ). The language of the description can be specified by attaching an 
  ##  xml.lang  attribute to the description element. If the description will be made available in a standalone context (i.e., in which its language cannot be inherited from a host content document), the language should always be specified. The 
  ##  DIAGRAM Description profile  provides the ability to compile one or more description elements into a single document for distribution (e.g., to accompany an EPUB). When storing a description in a standalone context, the Description feature namespace http://www.daisy.org/ns/z3998/authoring/features/description/ should be declared on the description element using the xmlns namespace association mechanism defined in 
  ##  refXMLNamespaces . Although not required, the prefix d is recommended. 
  element d:description {
    xml.id.attrib?,
    xml.lang.attrib?,
    xml.base.attrib?,
    z3998.feature.description.head?,
    z3998.feature.description.body
  }
z3998.feature.description.head =
  
  ## The description head element contains meta information about the enclosing 
  ##  description  element. The meta information in the description head element should not be treated as document content, but may be used for display and other purposes when rendering descriptions. Although all metadata is optional, descriptions should, at a minimum, include an identifier, the intended reader age and/or school grade level. See the 
  ##  DIAGRAM Descriptions Vocabulary  for a set of predefined RDF properties. Properties from other RDF vocabularies can also be included, provided their prefix is declared. If age and grade-level metadata is omitted, the containing description should be assumed to be applicable to all readers. 
  element d:head {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    ssml.onlangfailure.attrib?,
    z3998.meta+
  }
z3998.feature.description.body =
  
  ## The description body element contains the accessible description forms that readers can select from depending on their needs. The description body must minimally contain the primary description of the associated content in a child 
  ##  longdesc  element. The description body may also optionally compliment the primary description with a briefer 
  ##  summary  and a 
  ##  simplified language representation . The body of the description can also be used to carry alternative images for readers unable to adequately interact with the source image. The 
  ##  tactile  element can be used to include a tactile image and accompanying 
  ##  tour , and the 
  ##  simplifiedImage  element can be used to include images more accessible to various reader needs. 
  element d:body {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.feature.description.body.summary?
     & z3998.feature.description.body.longdesc
     & z3998.feature.description.body.simplifiedLanguageDescription?
     & z3998.feature.description.body.tactile?
     & z3998.feature.description.body.simplifiedImage?
     & z3998.annotation*)
  }
z3998.feature.description.body.summary =
  
  ## The summary element contains a shorter, more succinct version of the primary description in the 
  ##  longdesc  element. 
  element d:summary {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((text
      | z3998.object.text
      | z3998.sub
      | z3998.sup
      | z3998.char
      | z3998.span.text
      | z3998.emph.text
      | ssml.break
      | ssml.phoneme.text
      | ssml.prosody.text
      | ssml.say-as.text
      | ssml.sub.text
      | ssml.token.text
      | its-ruby
      | z3998.span
      | z3998.ref
      | z3998.code.phrase
      | z3998.object.phrase
      | z3998.address.phrase
      | z3998.noteref
      | z3998.note.phrase
      | z3998.annoref
      | z3998.ln
      | z3998.s
      | z3998.w
      | z3998.w
      | z3998.expansion
      | z3998.abbr
      | z3998.emph
      | z3998.time
      | z3998.name
      | z3998.definition
      | z3998.term
      | z3998.d
      | z3998.num
      | z3998.rend.linebreak
      | z3998.quote.phrase
      | z3998.citation
      | z3998.annotation.phrase
      | ssml.break
      | ssml.phoneme
      | ssml.prosody
      | ssml.say-as
      | ssml.sub
      | ssml.token
      | math
      | z3998.select.phrase
      | xforms.input
      | xforms.textarea
      | xforms.secret
      | xforms.select1
      | xforms.select
      | xforms.range
      | z3998.pagebreak)+
     | z3998.hd
     | z3998.block
     | z3998.p
     | z3998.transition
     | z3998.list
     | z3998.table
     | z3998.code.block
     | z3998.quote.block
     | z3998.citation.block
     | z3998.object.block
     | z3998.address
     | z3998.note
     | z3998.annotation
     | z3998.aside
     | z3998.caption
     | z3998.verse)
    >> sch:rule [
         context = "d:summary"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The summary element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.feature.description.body.longdesc =
  
  ## The longdesc element contains the primary description of the associated image, graphic or visually-oriented structure. The longdesc should contain a comprehensive explanation of the referenced item. See the 
  ##  summary  element for information on how to include a compact description. 
  element d:longdesc {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "d:longdesc"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The longdesc element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.feature.description.body.simplifiedLanguageDescription =
  
  ## The simplifiedLanguageDescription element contains a simplified language version of the primary description in the 
  ##  longdesc  element. 
  element d:simplifiedLanguageDescription {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
    >> sch:rule [
         context = "d:simplifiedLanguageDescription"
         "\x{a}" ~
         "                "
         sch:assert [
           test = "normalize-space(.) or *"
           "The simplifiedLanguageDescription element must neither be empty nor contain only whitespace. "
         ]
         "\x{a}" ~
         "            "
       ]
  }
z3998.feature.description.body.tactile =
  
  ## The tactile element contains an alternative tactile image. The element may contain one or more identical images for different production methods (e.g., one for swell paper production and another for stereolithograph printing). The tactile image may also include an explanatory 
  ##  tour . This specification does not place any restrictions on the format used to represent the tactile image, but images should be final-form representations for output rendering by end users. The 
  ##  role  attribute should be used to differentiate the production use for each image. 
  element d:tactile {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.object.block+, z3998.feature.description.tour?)
  }
z3998.feature.description.tour =
  
  ## The tour element is associated with a tactile graphic or a simplified alternative image, and provides orientation. In addition, the tour can explain how to explore the tactile or simplified image. 
  element d:tour {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((z3998.hd
      | z3998.block
      | z3998.p
      | z3998.transition
      | z3998.list
      | z3998.table
      | z3998.code.block
      | z3998.quote.block
      | z3998.citation.block
      | z3998.object.block
      | z3998.address
      | z3998.note
      | z3998.annotation
      | z3998.aside
      | z3998.caption
      | z3998.verse
      | z3998.description
      | ssml.break
      | math
      | z3998.select.block
      | xforms.group
      | xforms.repeat
      | z3998.feature.description
      | z3998.pagebreak)+
     | (text
        | z3998.object.text
        | z3998.sub
        | z3998.sup
        | z3998.char
        | z3998.span.text
        | z3998.emph.text
        | ssml.break
        | ssml.phoneme.text
        | ssml.prosody.text
        | ssml.say-as.text
        | ssml.sub.text
        | ssml.token.text
        | its-ruby
        | z3998.span
        | z3998.ref
        | z3998.code.phrase
        | z3998.object.phrase
        | z3998.address.phrase
        | z3998.noteref
        | z3998.note.phrase
        | z3998.annoref
        | z3998.ln
        | z3998.s
        | z3998.w
        | z3998.w
        | z3998.expansion
        | z3998.abbr
        | z3998.emph
        | z3998.time
        | z3998.name
        | z3998.definition
        | z3998.term
        | z3998.d
        | z3998.num
        | z3998.rend.linebreak
        | z3998.quote.phrase
        | z3998.citation
        | z3998.annotation.phrase
        | ssml.break
        | ssml.phoneme
        | ssml.prosody
        | ssml.say-as
        | ssml.sub
        | ssml.token
        | math
        | z3998.select.phrase
        | xforms.input
        | xforms.textarea
        | xforms.secret
        | xforms.select1
        | xforms.select
        | xforms.range
        | z3998.pagebreak)+)
  }
z3998.feature.description.body.simplifiedImage =
  
  ## The simplifiedImage element contains a simplified version of the source image. The element may contain one or more identical images in different formats. The simplified image may also include an explanatory 
  ##  tour . 
  element d:simplifiedImage {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    (z3998.object.block+, z3998.feature.description.tour?)
  }

## An ID TokenizedType, as defined in section 3.3.1 of 
##  refXML . 
ID.datatype = xsd:ID

## An IDREF TokenizedType, as defined in section 3.3.1 of 
##  refXML . 
IDREF.datatype = xsd:IDREF

## A space-separated list of 
##  IDREF  TokenizedTypes. 
IDREFS.datatype = xsd:IDREFS

## A space-separated list of 
##  NMTOKEN.datatype  TokenizedTypes. 
NMTOKENS.datatype = xsd:NMTOKENS

## An XML non-colonized Name, as defined in section 3.3.7 of 
##  refXML . 
NCName.datatype = xsd:NCName

## A single character, as per section 2.2 of 
##  refXML . 
Character.datatype = xsd:string { length = "1" }

## Specifies a value that must contain at least one non-whitespace character after whitespace normalization rules have been applied to the attribute value, as expressed through the 
##  XSD  normalizedString datatype. 
NonEmptyString.datatype = xsd:token { minLength = "1" }

## A derivation of the 
##  XSD  time datatype that only includes hour and minute specifications. The lexical expression is hh:mm. 
TimeNoSeconds.datatype = xsd:string { pattern = "\d\d:\d\d" }

## A non-negative integer. 
NonNegativeInteger.datatype =
  xsd:nonNegativeInteger { pattern = "[0-9]+" }

## A positive integer. 
PositiveInteger.datatype = xsd:positiveInteger { pattern = "[0-9]+" }

## An integer. 
Integer.datatype = xsd:integer

## A Uniform Resource Identifier Reference, as defined by the anyURI type in 
##  refXMLSchemaPart2 . 
URI.datatype = xsd:anyURI

## Media type, as per 
##  refRFC2046 . 
MediaType.datatype =
  xsd:string {
    pattern = "[a-zA-Z0-9!#$&+\-\^_]+/[a-zA-Z0-9!#$&+\-\^_]+.*"
  }

## A time value as defined in CSS 2.1 
##  Times , e.g. 250ms, 3s. 
CSS.TimeValue.datatype = xsd:string { pattern = "([0-9]+\.)?[0-9]+m?s" }

## A single CURIE, as defined in 
##  refRDFa11 . 
CURIE.datatype =
  xsd:string { pattern = "(([\i-[:]][\c-[:]]*)?:)?[\i-[:]][\c-[:]]*" }
xforms.Linking.attrib.src = attribute src { URI.datatype }
math.attributes.display = attribute display { "block" | "inline" }
math.attributes.maxwidth = attribute maxwidth { length }
math.attributes.overflow =
  attribute overflow {
    "linebreak" | "scroll" | "elide" | "truncate" | "scale"
  }
math.attributes.altimg = attribute altimg { xsd:anyURI }
math.attributes.altimg-width = attribute altimg-width { length }
math.attributes.altimg-height = attribute altimg-height { length }
math.attributes.altimg-valign =
  attribute altimg-valign { length | "top" | "middle" | "bottom" }
math.attributes.alttext = attribute alttext { text }
math.attributes.cdgroup = attribute cdgroup { xsd:anyURI }
z3998.table.tr.tr =
  
  ## The tr element represents a single 
  ##  table  row of data. 
  element tr {
    xml.id.attrib?,
    xml.space.attrib?,
    xml.base.attrib?,
    z3998.class.attrib?,
    xml.lang.attrib?,
    its.dir.attrib?,
    its.translate.attrib?,
    rdfa.about.attrib?,
    rdfa.content.attrib?,
    rdfa.datatype.attrib?,
    rdfa.typeof.attrib?,
    rdfa.property.attrib?,
    rdfa.rel.attrib?,
    rdfa.resource.attrib?,
    rdfa.rev.attrib?,
    z3998.desc.attrib?,
    z3998.by.attrib?,
    z3998.select.selid.attrib?,
    z3998.role.attrib?,
    z3998.continuation.attrib?,
    ssml.onlangfailure.attrib?,
    ((z3998.table.th | z3998.table.td)+ & z3998.pagebreak*)
  }
